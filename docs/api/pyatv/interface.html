---
layout: template
title: API - pyatv.interface
permalink: /api//interface
link_group: api
---
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyatv" href="index">pyatv</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyatv.interface.retrieve_commands" href="#pyatv.interface.retrieve_commands">retrieve_commands</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyatv.interface.App" href="#pyatv.interface.App">App</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.App.identifier" href="#pyatv.interface.App.identifier">identifier</a></code></li>
<li><code><a title="pyatv.interface.App.name" href="#pyatv.interface.App.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.AppleTV" href="#pyatv.interface.AppleTV">AppleTV</a></code></h4>
<ul class="two-column">
<li><code><a title="pyatv.interface.AppleTV.close" href="#pyatv.interface.AppleTV.close">close</a></code></li>
<li><code><a title="pyatv.interface.AppleTV.connect" href="#pyatv.interface.AppleTV.connect">connect</a></code></li>
<li><code><a title="pyatv.interface.AppleTV.device_info" href="#pyatv.interface.AppleTV.device_info">device_info</a></code></li>
<li><code><a title="pyatv.interface.AppleTV.features" href="#pyatv.interface.AppleTV.features">features</a></code></li>
<li><code><a title="pyatv.interface.AppleTV.metadata" href="#pyatv.interface.AppleTV.metadata">metadata</a></code></li>
<li><code><a title="pyatv.interface.AppleTV.power" href="#pyatv.interface.AppleTV.power">power</a></code></li>
<li><code><a title="pyatv.interface.AppleTV.push_updater" href="#pyatv.interface.AppleTV.push_updater">push_updater</a></code></li>
<li><code><a title="pyatv.interface.AppleTV.remote_control" href="#pyatv.interface.AppleTV.remote_control">remote_control</a></code></li>
<li><code><a title="pyatv.interface.AppleTV.service" href="#pyatv.interface.AppleTV.service">service</a></code></li>
<li><code><a title="pyatv.interface.AppleTV.stream" href="#pyatv.interface.AppleTV.stream">stream</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.ArtworkInfo" href="#pyatv.interface.ArtworkInfo">ArtworkInfo</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.ArtworkInfo.bytes" href="#pyatv.interface.ArtworkInfo.bytes">bytes</a></code></li>
<li><code><a title="pyatv.interface.ArtworkInfo.height" href="#pyatv.interface.ArtworkInfo.height">height</a></code></li>
<li><code><a title="pyatv.interface.ArtworkInfo.mimetype" href="#pyatv.interface.ArtworkInfo.mimetype">mimetype</a></code></li>
<li><code><a title="pyatv.interface.ArtworkInfo.width" href="#pyatv.interface.ArtworkInfo.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.BaseService" href="#pyatv.interface.BaseService">BaseService</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.BaseService.identifier" href="#pyatv.interface.BaseService.identifier">identifier</a></code></li>
<li><code><a title="pyatv.interface.BaseService.merge" href="#pyatv.interface.BaseService.merge">merge</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.DeviceInfo" href="#pyatv.interface.DeviceInfo">DeviceInfo</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.DeviceInfo.build_number" href="#pyatv.interface.DeviceInfo.build_number">build_number</a></code></li>
<li><code><a title="pyatv.interface.DeviceInfo.mac" href="#pyatv.interface.DeviceInfo.mac">mac</a></code></li>
<li><code><a title="pyatv.interface.DeviceInfo.model" href="#pyatv.interface.DeviceInfo.model">model</a></code></li>
<li><code><a title="pyatv.interface.DeviceInfo.operating_system" href="#pyatv.interface.DeviceInfo.operating_system">operating_system</a></code></li>
<li><code><a title="pyatv.interface.DeviceInfo.version" href="#pyatv.interface.DeviceInfo.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.DeviceListener" href="#pyatv.interface.DeviceListener">DeviceListener</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.DeviceListener.connection_closed" href="#pyatv.interface.DeviceListener.connection_closed">connection_closed</a></code></li>
<li><code><a title="pyatv.interface.DeviceListener.connection_lost" href="#pyatv.interface.DeviceListener.connection_lost">connection_lost</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.FeatureInfo" href="#pyatv.interface.FeatureInfo">FeatureInfo</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.FeatureInfo.options" href="#pyatv.interface.FeatureInfo.options">options</a></code></li>
<li><code><a title="pyatv.interface.FeatureInfo.state" href="#pyatv.interface.FeatureInfo.state">state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.Features" href="#pyatv.interface.Features">Features</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.Features.all_features" href="#pyatv.interface.Features.all_features">all_features</a></code></li>
<li><code><a title="pyatv.interface.Features.get_feature" href="#pyatv.interface.Features.get_feature">get_feature</a></code></li>
<li><code><a title="pyatv.interface.Features.in_state" href="#pyatv.interface.Features.in_state">in_state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.Metadata" href="#pyatv.interface.Metadata">Metadata</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.Metadata.app" href="#pyatv.interface.Metadata.app">app</a></code></li>
<li><code><a title="pyatv.interface.Metadata.artwork" href="#pyatv.interface.Metadata.artwork">artwork</a></code></li>
<li><code><a title="pyatv.interface.Metadata.artwork_id" href="#pyatv.interface.Metadata.artwork_id">artwork_id</a></code></li>
<li><code><a title="pyatv.interface.Metadata.device_id" href="#pyatv.interface.Metadata.device_id">device_id</a></code></li>
<li><code><a title="pyatv.interface.Metadata.playing" href="#pyatv.interface.Metadata.playing">playing</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.PairingHandler" href="#pyatv.interface.PairingHandler">PairingHandler</a></code></h4>
<ul class="two-column">
<li><code><a title="pyatv.interface.PairingHandler.begin" href="#pyatv.interface.PairingHandler.begin">begin</a></code></li>
<li><code><a title="pyatv.interface.PairingHandler.close" href="#pyatv.interface.PairingHandler.close">close</a></code></li>
<li><code><a title="pyatv.interface.PairingHandler.device_provides_pin" href="#pyatv.interface.PairingHandler.device_provides_pin">device_provides_pin</a></code></li>
<li><code><a title="pyatv.interface.PairingHandler.finish" href="#pyatv.interface.PairingHandler.finish">finish</a></code></li>
<li><code><a title="pyatv.interface.PairingHandler.has_paired" href="#pyatv.interface.PairingHandler.has_paired">has_paired</a></code></li>
<li><code><a title="pyatv.interface.PairingHandler.pin" href="#pyatv.interface.PairingHandler.pin">pin</a></code></li>
<li><code><a title="pyatv.interface.PairingHandler.service" href="#pyatv.interface.PairingHandler.service">service</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.Playing" href="#pyatv.interface.Playing">Playing</a></code></h4>
<ul class="two-column">
<li><code><a title="pyatv.interface.Playing.album" href="#pyatv.interface.Playing.album">album</a></code></li>
<li><code><a title="pyatv.interface.Playing.artist" href="#pyatv.interface.Playing.artist">artist</a></code></li>
<li><code><a title="pyatv.interface.Playing.device_state" href="#pyatv.interface.Playing.device_state">device_state</a></code></li>
<li><code><a title="pyatv.interface.Playing.genre" href="#pyatv.interface.Playing.genre">genre</a></code></li>
<li><code><a title="pyatv.interface.Playing.hash" href="#pyatv.interface.Playing.hash">hash</a></code></li>
<li><code><a title="pyatv.interface.Playing.media_type" href="#pyatv.interface.Playing.media_type">media_type</a></code></li>
<li><code><a title="pyatv.interface.Playing.position" href="#pyatv.interface.Playing.position">position</a></code></li>
<li><code><a title="pyatv.interface.Playing.repeat" href="#pyatv.interface.Playing.repeat">repeat</a></code></li>
<li><code><a title="pyatv.interface.Playing.shuffle" href="#pyatv.interface.Playing.shuffle">shuffle</a></code></li>
<li><code><a title="pyatv.interface.Playing.title" href="#pyatv.interface.Playing.title">title</a></code></li>
<li><code><a title="pyatv.interface.Playing.total_time" href="#pyatv.interface.Playing.total_time">total_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.Power" href="#pyatv.interface.Power">Power</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.Power.power_state" href="#pyatv.interface.Power.power_state">power_state</a></code></li>
<li><code><a title="pyatv.interface.Power.turn_off" href="#pyatv.interface.Power.turn_off">turn_off</a></code></li>
<li><code><a title="pyatv.interface.Power.turn_on" href="#pyatv.interface.Power.turn_on">turn_on</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.PowerListener" href="#pyatv.interface.PowerListener">PowerListener</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.PowerListener.powerstate_update" href="#pyatv.interface.PowerListener.powerstate_update">powerstate_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.PushListener" href="#pyatv.interface.PushListener">PushListener</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.PushListener.playstatus_error" href="#pyatv.interface.PushListener.playstatus_error">playstatus_error</a></code></li>
<li><code><a title="pyatv.interface.PushListener.playstatus_update" href="#pyatv.interface.PushListener.playstatus_update">playstatus_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.PushUpdater" href="#pyatv.interface.PushUpdater">PushUpdater</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.PushUpdater.active" href="#pyatv.interface.PushUpdater.active">active</a></code></li>
<li><code><a title="pyatv.interface.PushUpdater.post_update" href="#pyatv.interface.PushUpdater.post_update">post_update</a></code></li>
<li><code><a title="pyatv.interface.PushUpdater.start" href="#pyatv.interface.PushUpdater.start">start</a></code></li>
<li><code><a title="pyatv.interface.PushUpdater.stop" href="#pyatv.interface.PushUpdater.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.RemoteControl" href="#pyatv.interface.RemoteControl">RemoteControl</a></code></h4>
<ul class="two-column">
<li><code><a title="pyatv.interface.RemoteControl.down" href="#pyatv.interface.RemoteControl.down">down</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.home" href="#pyatv.interface.RemoteControl.home">home</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.home_hold" href="#pyatv.interface.RemoteControl.home_hold">home_hold</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.left" href="#pyatv.interface.RemoteControl.left">left</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.menu" href="#pyatv.interface.RemoteControl.menu">menu</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.next" href="#pyatv.interface.RemoteControl.next">next</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.pause" href="#pyatv.interface.RemoteControl.pause">pause</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.play" href="#pyatv.interface.RemoteControl.play">play</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.play_pause" href="#pyatv.interface.RemoteControl.play_pause">play_pause</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.previous" href="#pyatv.interface.RemoteControl.previous">previous</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.right" href="#pyatv.interface.RemoteControl.right">right</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.select" href="#pyatv.interface.RemoteControl.select">select</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.set_position" href="#pyatv.interface.RemoteControl.set_position">set_position</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.set_repeat" href="#pyatv.interface.RemoteControl.set_repeat">set_repeat</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.set_shuffle" href="#pyatv.interface.RemoteControl.set_shuffle">set_shuffle</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.skip_backward" href="#pyatv.interface.RemoteControl.skip_backward">skip_backward</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.skip_forward" href="#pyatv.interface.RemoteControl.skip_forward">skip_forward</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.stop" href="#pyatv.interface.RemoteControl.stop">stop</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.suspend" href="#pyatv.interface.RemoteControl.suspend">suspend</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.top_menu" href="#pyatv.interface.RemoteControl.top_menu">top_menu</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.up" href="#pyatv.interface.RemoteControl.up">up</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.volume_down" href="#pyatv.interface.RemoteControl.volume_down">volume_down</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.volume_up" href="#pyatv.interface.RemoteControl.volume_up">volume_up</a></code></li>
<li><code><a title="pyatv.interface.RemoteControl.wakeup" href="#pyatv.interface.RemoteControl.wakeup">wakeup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.StateProducer" href="#pyatv.interface.StateProducer">StateProducer</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.StateProducer.listener" href="#pyatv.interface.StateProducer.listener">listener</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyatv.interface.Stream" href="#pyatv.interface.Stream">Stream</a></code></h4>
<ul class="">
<li><code><a title="pyatv.interface.Stream.close" href="#pyatv.interface.Stream.close">close</a></code></li>
<li><code><a title="pyatv.interface.Stream.play_url" href="#pyatv.interface.Stream.play_url">play_url</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<article id="content">
<header>
<h1 class="title">Module <code>pyatv.interface</code></h1>
</header>
<section id="section-intro">
<p>Public interface exposed by library.</p>
<p>This module contains all the interfaces that represents a generic Apple TV device and
all its features.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Public interface exposed by library.

This module contains all the interfaces that represents a generic Apple TV device and
all its features.
&#34;&#34;&#34;

import asyncio
import re
import inspect
import hashlib
from typing import (
    Any,
    Dict,
    Mapping,
    MutableMapping,
    Optional,
    NamedTuple,
    Callable,
    TypeVar,
    Tuple,
    Union,
    List,
)
import weakref

from abc import ABC, abstractmethod

from pyatv import const, convert, exceptions
from pyatv.const import (
    Protocol,
    OperatingSystem,
    DeviceModel,
    FeatureState,
    FeatureName,
    InputAction,
)
from pyatv.support import net

__pdoc__ = {}
__pdoc__[&#34;feature&#34;] = False

_ALL_FEATURES = {}  # type: Dict[int, Tuple[str, str]]

ReturnType = TypeVar(&#34;ReturnType&#34;, bound=Callable[..., Any])


class ArtworkInfo(NamedTuple):
    &#34;&#34;&#34;Artwork information.&#34;&#34;&#34;

    bytes: bytes
    mimetype: str
    width: int
    height: int


class FeatureInfo(NamedTuple):
    &#34;&#34;&#34;Feature state and options.&#34;&#34;&#34;

    state: FeatureState
    options: Optional[Dict[str, object]] = {}


class _ListenerProxy:
    &#34;&#34;&#34;Proxy to call functions in a listener.

    A proxy instance maintains a weak reference to a listener object and allows calling
    functions in the listener. If no listener is set or the weak reference has expired,
    a null-function (doing nothing) is returned so that nothing happens. This makes it
    safe to call functions without having to check if either a listener has been set at
    all or if the listener implements the called function.
    &#34;&#34;&#34;

    def __init__(self, listener):
        &#34;&#34;&#34;Initialize a new ListenerProxy instance.&#34;&#34;&#34;
        self.listener = listener

    def __getattr__(self, attr):
        &#34;&#34;&#34;Dynamically find target method in listener.&#34;&#34;&#34;
        if self.listener is not None:
            listener = self.listener()
            if hasattr(listener, attr):
                return getattr(listener, attr)

        return lambda *args, **kwargs: None


class StateProducer:
    &#34;&#34;&#34;Base class for objects announcing state changes to a listener.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize a new StateProducer instance.&#34;&#34;&#34;
        self.__listener: Optional[weakref.ReferenceType[Any]] = None

    @property
    def listener(self):
        &#34;&#34;&#34;Return current listener object.&#34;&#34;&#34;
        return _ListenerProxy(self.__listener)

    @listener.setter
    def listener(self, target) -&gt; None:
        &#34;&#34;&#34;Change current listener object.

        Set to None to remove active listener.
        &#34;&#34;&#34;
        if target is not None:
            self.__listener = weakref.ref(target)
        else:
            self.__listener = None


def feature(index: int, name: str, doc: str) -&gt; Callable[[ReturnType], ReturnType]:
    &#34;&#34;&#34;Decorate functions and properties as a feature.

    Note: This is an internal function.
    &#34;&#34;&#34;

    def _feat_decorator(func: ReturnType) -&gt; ReturnType:
        if index in _ALL_FEATURES:
            raise Exception(
                f&#34;Index {index} collides between {name} and {_ALL_FEATURES[index]}&#34;
            )
        _ALL_FEATURES[index] = (name, doc)

        return func

    return _feat_decorator


def _get_first_sentence_in_pydoc(obj):
    doc = obj.__doc__
    index = doc.find(&#34;.&#34;)
    if index == -1:
        # Here we have no leading . so return everything
        return doc

    # Try to find the first complete sentence and respect
    # abbreviations correctly
    match = re.findall(r&#34;(.*\.[^A-Z]*)\.(?: [A-Z].*|)&#34;, doc)
    if len(match) == 1:
        return match[0]
    return doc[0:index]


def retrieve_commands(obj: object):
    &#34;&#34;&#34;Retrieve all commands and help texts from an API object.&#34;&#34;&#34;
    commands = {}  # type: Dict[str, str]
    for func in obj.__dict__:
        if not inspect.isfunction(obj.__dict__[func]) and not isinstance(
            obj.__dict__[func], property
        ):
            continue
        if func.startswith(&#34;_&#34;) or func == &#34;listener&#34;:
            continue
        commands[func] = _get_first_sentence_in_pydoc(obj.__dict__[func])
    return commands


class BaseService:
    &#34;&#34;&#34;Base class for protocol services.&#34;&#34;&#34;

    def __init__(
        self,
        identifier: Optional[str],
        protocol: Protocol,
        port: int,
        properties: Optional[Mapping[str, str]],
    ) -&gt; None:
        &#34;&#34;&#34;Initialize a new BaseService.&#34;&#34;&#34;
        self.__identifier = identifier
        self.protocol = protocol
        self.port = port
        self.credentials: Optional[str] = None
        self.properties: MutableMapping[str, str] = dict(properties or {})

    @property
    def identifier(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Return unique identifier associated with this service.&#34;&#34;&#34;
        return self.__identifier

    def merge(self, other) -&gt; None:
        &#34;&#34;&#34;Merge with other service of same type.&#34;&#34;&#34;
        self.credentials = other.credentials or self.credentials
        self.properties.update(other.properties)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of this object.&#34;&#34;&#34;
        return &#34;Protocol: {0}, Port: {1}, Credentials: {2}&#34;.format(
            convert.protocol_str(self.protocol), self.port, self.credentials
        )


class PairingHandler(ABC):
    &#34;&#34;&#34;Base class for API used to pair with an Apple TV.&#34;&#34;&#34;

    def __init__(
        self, session_manager: net.ClientSessionManager, service: BaseService
    ) -&gt; None:
        &#34;&#34;&#34;Initialize a new instance of PairingHandler.&#34;&#34;&#34;
        self.session_manager = session_manager
        self._service = service

    @property
    def service(self) -&gt; BaseService:
        &#34;&#34;&#34;Return service used for pairing.&#34;&#34;&#34;
        return self._service

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Call to free allocated resources after pairing.&#34;&#34;&#34;
        await self.session_manager.close()

    @abstractmethod
    def pin(self, pin) -&gt; None:
        &#34;&#34;&#34;Pin code used for pairing.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def device_provides_pin(self) -&gt; bool:
        &#34;&#34;&#34;Return True if remote device presents PIN code, else False.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def has_paired(self) -&gt; bool:
        &#34;&#34;&#34;If a successful pairing has been performed.

        The value will be reset when stop() is called.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    async def begin(self) -&gt; None:
        &#34;&#34;&#34;Start pairing process.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    async def finish(self) -&gt; None:
        &#34;&#34;&#34;Stop pairing process.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()


class RemoteControl(ABC):  # pylint: disable=too-many-public-methods
    &#34;&#34;&#34;Base class for API used to control an Apple TV.&#34;&#34;&#34;

    # pylint: disable=invalid-name
    @abstractmethod
    @feature(0, &#34;Up&#34;, &#34;Up button on remote.&#34;)
    async def up(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key up.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(1, &#34;Down&#34;, &#34;Down button on remote.&#34;)
    async def down(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key down.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(2, &#34;Left&#34;, &#34;Left button on remote.&#34;)
    async def left(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key left.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(3, &#34;Right&#34;, &#34;Right button on remote.&#34;)
    async def right(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key right.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(4, &#34;Play&#34;, &#34;Start playing media.&#34;)
    async def play(self) -&gt; None:
        &#34;&#34;&#34;Press key play.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(5, &#34;PlayPause&#34;, &#34;Toggle between play/pause.&#34;)
    async def play_pause(self) -&gt; None:
        &#34;&#34;&#34;Toggle between play and pause.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(6, &#34;Pause&#34;, &#34;Pause playing media.&#34;)
    async def pause(self) -&gt; None:
        &#34;&#34;&#34;Press key play.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(7, &#34;Stop&#34;, &#34;Stop playing media.&#34;)
    async def stop(self) -&gt; None:
        &#34;&#34;&#34;Press key stop.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(8, &#34;Next&#34;, &#34;Change to next item.&#34;)
    async def next(self) -&gt; None:
        &#34;&#34;&#34;Press key next.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(9, &#34;Previous&#34;, &#34;Change to previous item.&#34;)
    async def previous(self) -&gt; None:
        &#34;&#34;&#34;Press key previous.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(10, &#34;Select&#34;, &#34;Select current option.&#34;)
    async def select(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key select.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(11, &#34;Menu&#34;, &#34;Go back to previous menu.&#34;)
    async def menu(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key menu.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(12, &#34;VolumeUp&#34;, &#34;Increase volume.&#34;)
    async def volume_up(self) -&gt; None:
        &#34;&#34;&#34;Press key volume up.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(13, &#34;VolumeDown&#34;, &#34;Decrease volume.&#34;)
    async def volume_down(self) -&gt; None:
        &#34;&#34;&#34;Press key volume down.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(14, &#34;Home&#34;, &#34;Home/TV button.&#34;)
    async def home(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key home.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(
        15, &#34;HomeHold&#34;, &#34;Long-press home button (deprecated: use RemoteControl.home).&#34;
    )
    async def home_hold(self) -&gt; None:
        &#34;&#34;&#34;Hold key home.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(16, &#34;TopMenu&#34;, &#34;Go to main menu.&#34;)
    async def top_menu(self) -&gt; None:
        &#34;&#34;&#34;Go to main menu (long press menu).&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(17, &#34;Suspend&#34;, &#34;Suspend device (deprecated; use Power.turn_off).&#34;)
    async def suspend(self) -&gt; None:
        &#34;&#34;&#34;Suspend the device.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(18, &#34;WakeUp&#34;, &#34;Wake up device (deprecated; use Power.turn_on).&#34;)
    async def wakeup(self) -&gt; None:
        &#34;&#34;&#34;Wake up the device.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(
        36,
        &#34;SkipForward&#34;,
        &#34;Skip forward a time interval.&#34;,
    )
    async def skip_forward(self) -&gt; None:
        &#34;&#34;&#34;Skip forward a time interval.

        Skip interval is typically 15-30s, but is decided by the app.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(37, &#34;SkipBackward&#34;, &#34;Skip backwards a time interval.&#34;)
    async def skip_backward(self) -&gt; None:
        &#34;&#34;&#34;Skip backwards a time interval.

        Skip interval is typically 15-30s, but is decided by the app.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(19, &#34;SetPosition&#34;, &#34;Seek to position.&#34;)
    async def set_position(self, pos: int) -&gt; None:
        &#34;&#34;&#34;Seek in the current playing media.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(20, &#34;SetShuffle&#34;, &#34;Change shuffle state.&#34;)
    async def set_shuffle(self, shuffle_state: const.ShuffleState) -&gt; None:
        &#34;&#34;&#34;Change shuffle mode to on or off.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(21, &#34;SetRepeat&#34;, &#34;Change repeat state.&#34;)
    async def set_repeat(self, repeat_state: const.RepeatState) -&gt; None:
        &#34;&#34;&#34;Change repeat state.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()


# TODO: Should be made into a dataclass when support for 3.6 is dropped
class Playing(ABC):
    &#34;&#34;&#34;Base class for retrieving what is currently playing.&#34;&#34;&#34;

    _PROPERTIES = [
        &#34;media_type&#34;,
        &#34;device_state&#34;,
        &#34;title&#34;,
        &#34;artist&#34;,
        &#34;album&#34;,
        &#34;genre&#34;,
        &#34;total_time&#34;,
        &#34;position&#34;,
        &#34;shuffle&#34;,
        &#34;repeat&#34;,
        &#34;hash&#34;,
    ]

    def __init__(
        self,
        media_type: const.MediaType = const.MediaType.Unknown,
        device_state: const.DeviceState = const.DeviceState.Idle,
        title: Optional[str] = None,
        artist: Optional[str] = None,
        album: Optional[str] = None,
        genre: Optional[str] = None,
        total_time: Optional[int] = None,
        position: Optional[int] = None,
        shuffle: Optional[const.ShuffleState] = None,
        repeat: Optional[const.RepeatState] = None,
        hash: Optional[str] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize a new Playing instance.&#34;&#34;&#34;
        self._media_type = media_type
        self._device_state = device_state
        self._title = title
        self._artist = artist
        self._album = album
        self._genre = genre
        self._total_time = total_time
        self._position = position
        self._shuffle = shuffle
        self._repeat = repeat
        self._hash = hash

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Convert this playing object to a readable string.&#34;&#34;&#34;
        output = []
        output.append(
            &#34;  Media type: {0}&#34;.format(convert.media_type_str(self.media_type))
        )
        output.append(
            &#34;Device state: {0}&#34;.format(convert.device_state_str(self.device_state))
        )

        if self.title is not None:
            output.append(&#34;       Title: {0}&#34;.format(self.title))

        if self.artist is not None:
            output.append(&#34;      Artist: {0}&#34;.format(self.artist))

        if self.album is not None:
            output.append(&#34;       Album: {0}&#34;.format(self.album))

        if self.genre is not None:
            output.append(&#34;       Genre: {0}&#34;.format(self.genre))

        position = self.position
        total_time = self.total_time
        if position is not None and total_time is not None and total_time != 0:
            output.append(
                &#34;    Position: {0}/{1}s ({2:.1%})&#34;.format(
                    position, total_time, float(position) / float(total_time)
                )
            )
        elif position is not None and position != 0:
            output.append(&#34;    Position: {0}s&#34;.format(position))
        elif total_time is not None and position != 0:
            output.append(&#34;  Total time: {0}s&#34;.format(total_time))

        if self.repeat is not None:
            output.append(&#34;      Repeat: {0}&#34;.format(convert.repeat_str(self.repeat)))

        if self.shuffle is not None:
            output.append(&#34;     Shuffle: {0}&#34;.format(convert.shuffle_str(self.shuffle)))

        return &#34;\n&#34;.join(output)

    def __eq__(self, other):
        &#34;&#34;&#34;Compare if two objects are equal.&#34;&#34;&#34;
        if isinstance(other, Playing):
            for prop in self._PROPERTIES:
                if getattr(self, prop) != getattr(other, prop):
                    return False
            return True
        return False

    @property
    def hash(self) -&gt; str:
        &#34;&#34;&#34;Create a unique hash for what is currently playing.

        The hash is based on title, artist, album and total time. It should
        always be the same for the same content, but it is not guaranteed.
        &#34;&#34;&#34;
        if self._hash:
            return self._hash

        base = &#34;{0}{1}{2}{3}&#34;.format(
            self.title, self.artist, self.album, self.total_time
        )
        return hashlib.sha256(base.encode(&#34;utf-8&#34;)).hexdigest()

    @property
    def media_type(self) -&gt; const.MediaType:
        &#34;&#34;&#34;Type of media is currently playing, e.g. video, music.&#34;&#34;&#34;
        return self._media_type

    @property
    def device_state(self) -&gt; const.DeviceState:
        &#34;&#34;&#34;Device state, e.g. playing or paused.&#34;&#34;&#34;
        return self._device_state

    @property  # type: ignore
    @feature(22, &#34;Title&#34;, &#34;Title of playing media.&#34;)
    def title(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Title of the current media, e.g. movie or song name.&#34;&#34;&#34;
        return self._title

    @property  # type: ignore
    @feature(23, &#34;Artist&#34;, &#34;Artist of playing song.&#34;)
    def artist(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Artist of the currently playing song.&#34;&#34;&#34;
        return self._artist

    @property  # type: ignore
    @feature(24, &#34;Album&#34;, &#34;Album from playing artist.&#34;)
    def album(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Album of the currently playing song.&#34;&#34;&#34;
        return self._album

    @property  # type: ignore
    @feature(25, &#34;Genre&#34;, &#34;Genre of playing song.&#34;)
    def genre(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Genre of the currently playing song.&#34;&#34;&#34;
        return self._genre

    @property  # type: ignore
    @feature(26, &#34;TotalTime&#34;, &#34;Total length of playing media (seconds).&#34;)
    def total_time(self) -&gt; Optional[int]:
        &#34;&#34;&#34;Total play time in seconds.&#34;&#34;&#34;
        return self._total_time

    @property  # type: ignore
    @feature(27, &#34;Position&#34;, &#34;Current play time position.&#34;)
    def position(self) -&gt; Optional[int]:
        &#34;&#34;&#34;Position in the playing media (seconds).&#34;&#34;&#34;
        return self._position

    @property  # type: ignore
    @feature(28, &#34;Shuffle&#34;, &#34;Shuffle state.&#34;)
    def shuffle(self) -&gt; Optional[const.ShuffleState]:
        &#34;&#34;&#34;If shuffle is enabled or not.&#34;&#34;&#34;
        return self._shuffle

    @property  # type: ignore
    @feature(29, &#34;Repeat&#34;, &#34;Repeat state.&#34;)
    def repeat(self) -&gt; Optional[const.RepeatState]:
        &#34;&#34;&#34;Repeat mode.&#34;&#34;&#34;
        return self._repeat


class App:
    &#34;&#34;&#34;Information about an app.&#34;&#34;&#34;

    def __init__(self, name: Optional[str], identifier: str) -&gt; None:
        &#34;&#34;&#34;Initialize a new App instance.&#34;&#34;&#34;
        self._name = name
        self._identifier = identifier

    @property
    def name(self) -&gt; Optional[str]:
        &#34;&#34;&#34;User friendly name of app.&#34;&#34;&#34;
        return self._name

    @property
    def identifier(self) -&gt; str:
        &#34;&#34;&#34;Return a unique bundle id for the app.&#34;&#34;&#34;
        return self._identifier

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Convert app info to readable string.&#34;&#34;&#34;
        return f&#34;App: {self.name} ({self.identifier})&#34;


class Metadata(ABC):
    &#34;&#34;&#34;Base class for retrieving metadata from an Apple TV.&#34;&#34;&#34;

    def __init__(self, identifier: str) -&gt; None:
        &#34;&#34;&#34;Initialize a new instance of Metadata.&#34;&#34;&#34;
        self._identifier = identifier

    @property
    def device_id(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Return a unique identifier for current device.&#34;&#34;&#34;
        return self._identifier

    @abstractmethod
    @feature(30, &#34;Artwork&#34;, &#34;Playing media artwork.&#34;)
    async def artwork(self, width=512, height=None) -&gt; Optional[ArtworkInfo]:
        &#34;&#34;&#34;Return artwork for what is currently playing (or None).

        The parameters &#34;width&#34; and &#34;height&#34; makes it possible to request artwork of a
        specific size. This is just a request, the device might impose restrictions and
        return artwork of a different size. Set both parameters to None to request
        default size. Set one of them and let the other one be None to keep original
        aspect ratio.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def artwork_id(self) -&gt; str:
        &#34;&#34;&#34;Return a unique identifier for current artwork.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    async def playing(self) -&gt; Playing:
        &#34;&#34;&#34;Return what is currently playing.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property  # type: ignore
    @abstractmethod
    @feature(35, &#34;App&#34;, &#34;App playing media.&#34;)
    def app(self) -&gt; Optional[App]:
        &#34;&#34;&#34;Return information about current app playing something.

        Do note that this property returns which app is currently playing something and
        not which app is currently active. If nothing is playing, the corresponding
        feature will be unavailable.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()


class PushListener(ABC):
    &#34;&#34;&#34;Listener interface for push updates.&#34;&#34;&#34;

    @abstractmethod
    def playstatus_update(self, updater, playstatus: Playing) -&gt; None:
        &#34;&#34;&#34;Inform about changes to what is currently playing.&#34;&#34;&#34;

    @abstractmethod
    def playstatus_error(self, updater, exception: Exception) -&gt; None:
        &#34;&#34;&#34;Inform about an error when updating play status.&#34;&#34;&#34;


class PushUpdater(ABC, StateProducer):
    &#34;&#34;&#34;Base class for push/async updates from an Apple TV.

    Listener interface: `pyatv.interface.PushListener`
    &#34;&#34;&#34;

    def __init__(self, loop: asyncio.AbstractEventLoop):
        &#34;&#34;&#34;Initialize a new PushUpdater.&#34;&#34;&#34;
        self.loop = loop
        self._previous_state: Optional[Playing] = None

    @property
    @abstractmethod
    def active(self) -&gt; bool:
        &#34;&#34;&#34;Return if push updater has been started.&#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def start(self, initial_delay: int = 0) -&gt; None:
        &#34;&#34;&#34;Begin to listen to updates.

        If an error occurs, start must be called again.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def stop(self) -&gt; None:
        &#34;&#34;&#34;No longer forward updates to listener.&#34;&#34;&#34;
        raise NotImplementedError

    def post_update(self, playing: Playing) -&gt; None:
        &#34;&#34;&#34;Post an update to listener.&#34;&#34;&#34;
        if playing != self._previous_state:
            self.loop.call_soon(self.listener.playstatus_update, self, playing)

        self._previous_state = playing


class Stream(ABC):  # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Base class for stream functionality.&#34;&#34;&#34;

    @abstractmethod
    def close(self) -&gt; None:
        &#34;&#34;&#34;Close connection and release allocated resources.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(31, &#34;PlayUrl&#34;, &#34;Stream a URL on device.&#34;)
    async def play_url(self, url: str, **kwargs) -&gt; None:
        &#34;&#34;&#34;Play media from an URL on the device.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()


class DeviceListener(ABC):
    &#34;&#34;&#34;Listener interface for generic device updates.&#34;&#34;&#34;

    @abstractmethod
    def connection_lost(self, exception: Exception) -&gt; None:
        &#34;&#34;&#34;Device was unexpectedly disconnected.&#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def connection_closed(self) -&gt; None:
        &#34;&#34;&#34;Device connection was (intentionally) closed.&#34;&#34;&#34;
        raise NotImplementedError()


class PowerListener(ABC):  # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Listener interface for power updates.&#34;&#34;&#34;

    @abstractmethod
    def powerstate_update(
        self, old_state: const.PowerState, new_state: const.PowerState
    ):
        &#34;&#34;&#34;Device power state was updated.&#34;&#34;&#34;
        raise NotImplementedError()


class Power(ABC, StateProducer):
    &#34;&#34;&#34;Base class for retrieving power state from an Apple TV.

    Listener interface: `pyatv.interfaces.PowerListener`
    &#34;&#34;&#34;

    @property  # type: ignore
    @abstractmethod
    @feature(32, &#34;PowerState&#34;, &#34;Current device power state.&#34;)
    def power_state(self) -&gt; const.PowerState:
        &#34;&#34;&#34;Return device power state.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(33, &#34;TurnOn&#34;, &#34;Turn device on.&#34;)
    async def turn_on(self, await_new_state: bool = False) -&gt; None:
        &#34;&#34;&#34;Turn device on.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(34, &#34;TurnOff&#34;, &#34;Turn off device.&#34;)
    async def turn_off(self, await_new_state: bool = False) -&gt; None:
        &#34;&#34;&#34;Turn device off.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()


class DeviceInfo:
    &#34;&#34;&#34;General information about device.&#34;&#34;&#34;

    def __init__(
        self,
        os: const.OperatingSystem,
        version: Optional[str],
        build_number: Optional[str],
        model: const.DeviceModel,
        mac: Optional[str],
    ) -&gt; None:  # pylint: disable=too-many-arguments  # noqa
        &#34;&#34;&#34;Initialize a new DeviceInfo instance.&#34;&#34;&#34;
        self._os = os
        self._version = version
        self._build_number = build_number
        self._model = model
        self._mac = mac

    @property
    def operating_system(self) -&gt; const.OperatingSystem:
        &#34;&#34;&#34;Operating system running on device.&#34;&#34;&#34;
        return self._os

    @property
    def version(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Operating system version.&#34;&#34;&#34;
        return self._version

    @property
    def build_number(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Operating system build number, e.g. 17K795.&#34;&#34;&#34;
        return self._build_number

    @property
    def model(self) -&gt; const.DeviceModel:
        &#34;&#34;&#34;Hardware model name, e.g. 3, 4 or 4K.&#34;&#34;&#34;
        return self._model

    @property
    def mac(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Device MAC address.&#34;&#34;&#34;
        return self._mac

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Convert device info to readable string.&#34;&#34;&#34;
        if self.model != DeviceModel.Unknown:
            output = self.model.name.replace(&#34;Gen&#34;, &#34;&#34;)
        else:
            output = &#34;Unknown Model&#34;

        output += (
            &#34; &#34;
            + {
                OperatingSystem.Legacy: &#34;ATV SW&#34;,
                OperatingSystem.TvOS: &#34;tvOS&#34;,
            }.get(self.operating_system, &#34;Unknown OS&#34;)
        )

        if self.version:
            output += &#34; &#34; + self.version

        if self.build_number:
            output += &#34; build &#34; + self.build_number

        return output


class Features(ABC):
    &#34;&#34;&#34;Base class for supported feature functionality.&#34;&#34;&#34;

    @abstractmethod
    def get_feature(self, feature: FeatureName) -&gt; FeatureInfo:
        &#34;&#34;&#34;Return current state of a feature.&#34;&#34;&#34;
        raise NotImplementedError()

    def all_features(self, include_unsupported=False) -&gt; Dict[FeatureName, FeatureInfo]:
        &#34;&#34;&#34;Return state of all features.&#34;&#34;&#34;
        features = {}  # type: Dict[FeatureName, FeatureInfo]
        for name in FeatureName:
            feature = self.get_feature(name)
            if feature.state != FeatureState.Unsupported or include_unsupported:
                features[name] = feature
        return features

    def in_state(
        self,
        states: Union[List[FeatureState], FeatureState],
        *feature_names: FeatureName
    ):
        &#34;&#34;&#34;Return if features are in a specific state.

        This method will return True if all given features are in the state specified
        by &#34;states&#34;. If &#34;states&#34; is a list of states, it is enough for the feature to be
        in one of the listed states.
        &#34;&#34;&#34;
        for name in feature_names:
            feature = self.get_feature(name)
            expected_states = states if isinstance(states, list) else [states]
            if feature.state not in expected_states:
                return False
        return True


class AppleTV(ABC, StateProducer):
    &#34;&#34;&#34;Base class representing an Apple TV.

    Listener interface: `pyatv.interfaces.DeviceListener`
    &#34;&#34;&#34;

    @abstractmethod
    async def connect(self) -&gt; None:
        &#34;&#34;&#34;Initiate connection to device.

        No need to call it yourself, it&#39;s done automatically.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    def close(self) -&gt; None:
        &#34;&#34;&#34;Close connection and release allocated resources.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def device_info(self) -&gt; DeviceInfo:
        &#34;&#34;&#34;Return API for device information.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def service(self) -&gt; BaseService:
        &#34;&#34;&#34;Return service used to connect to the Apple TV.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def remote_control(self) -&gt; RemoteControl:
        &#34;&#34;&#34;Return API for controlling the Apple TV.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def metadata(self) -&gt; Metadata:
        &#34;&#34;&#34;Return API for retrieving metadata from the Apple TV.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def push_updater(self) -&gt; PushUpdater:
        &#34;&#34;&#34;Return API for handling push update from the Apple TV.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def stream(self) -&gt; Stream:
        &#34;&#34;&#34;Return API for streaming media.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def power(self) -&gt; Power:
        &#34;&#34;&#34;Return API for power management.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def features(self) -&gt; Features:
        &#34;&#34;&#34;Return features interface.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyatv.interface.retrieve_commands"><code class="name flex">
<span>def <span class="ident">retrieve_commands</span></span>(<span>obj: object)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve all commands and help texts from an API object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_commands(obj: object):
    &#34;&#34;&#34;Retrieve all commands and help texts from an API object.&#34;&#34;&#34;
    commands = {}  # type: Dict[str, str]
    for func in obj.__dict__:
        if not inspect.isfunction(obj.__dict__[func]) and not isinstance(
            obj.__dict__[func], property
        ):
            continue
        if func.startswith(&#34;_&#34;) or func == &#34;listener&#34;:
            continue
        commands[func] = _get_first_sentence_in_pydoc(obj.__dict__[func])
    return commands</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyatv.interface.App"><code class="flex name class">
<span>class <span class="ident">App</span></span>
<span>(</span><span>name: Optional[str], identifier: str)</span>
</code></dt>
<dd>
<section class="desc"><p>Information about an app.</p>
<p>Initialize a new App instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class App:
    &#34;&#34;&#34;Information about an app.&#34;&#34;&#34;

    def __init__(self, name: Optional[str], identifier: str) -&gt; None:
        &#34;&#34;&#34;Initialize a new App instance.&#34;&#34;&#34;
        self._name = name
        self._identifier = identifier

    @property
    def name(self) -&gt; Optional[str]:
        &#34;&#34;&#34;User friendly name of app.&#34;&#34;&#34;
        return self._name

    @property
    def identifier(self) -&gt; str:
        &#34;&#34;&#34;Return a unique bundle id for the app.&#34;&#34;&#34;
        return self._identifier

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Convert app info to readable string.&#34;&#34;&#34;
        return f&#34;App: {self.name} ({self.identifier})&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.App.identifier"><code class="name">var <span class="ident">identifier</span> -> str</code></dt>
<dd>
<section class="desc"><p>Return a unique bundle id for the app.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def identifier(self) -&gt; str:
    &#34;&#34;&#34;Return a unique bundle id for the app.&#34;&#34;&#34;
    return self._identifier</code></pre>
</details>
</dd>
<dt id="pyatv.interface.App.name"><code class="name">var <span class="ident">name</span> -> Optional[str]</code></dt>
<dd>
<section class="desc"><p>User friendly name of app.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; Optional[str]:
    &#34;&#34;&#34;User friendly name of app.&#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.AppleTV"><code class="flex name class">
<span>class <span class="ident">AppleTV</span></span>
</code></dt>
<dd>
<section class="desc"><p>Base class representing an Apple TV.</p>
<p>Listener interface: <code>pyatv.interfaces.DeviceListener</code></p>
<p>Initialize a new StateProducer instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppleTV(ABC, StateProducer):
    &#34;&#34;&#34;Base class representing an Apple TV.

    Listener interface: `pyatv.interfaces.DeviceListener`
    &#34;&#34;&#34;

    @abstractmethod
    async def connect(self) -&gt; None:
        &#34;&#34;&#34;Initiate connection to device.

        No need to call it yourself, it&#39;s done automatically.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    def close(self) -&gt; None:
        &#34;&#34;&#34;Close connection and release allocated resources.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def device_info(self) -&gt; DeviceInfo:
        &#34;&#34;&#34;Return API for device information.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def service(self) -&gt; BaseService:
        &#34;&#34;&#34;Return service used to connect to the Apple TV.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def remote_control(self) -&gt; RemoteControl:
        &#34;&#34;&#34;Return API for controlling the Apple TV.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def metadata(self) -&gt; Metadata:
        &#34;&#34;&#34;Return API for retrieving metadata from the Apple TV.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def push_updater(self) -&gt; PushUpdater:
        &#34;&#34;&#34;Return API for handling push update from the Apple TV.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def stream(self) -&gt; Stream:
        &#34;&#34;&#34;Return API for streaming media.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def power(self) -&gt; Power:
        &#34;&#34;&#34;Return API for power management.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def features(self) -&gt; Features:
        &#34;&#34;&#34;Return features interface.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
<li><a title="pyatv.interface.StateProducer" href="#pyatv.interface.StateProducer">StateProducer</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyatv.dmap.DmapAppleTV</li>
<li>pyatv.mrp.MrpAppleTV</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.AppleTV.device_info"><code class="name">var <span class="ident">device_info</span> -> <a title="pyatv.interface.DeviceInfo" href="#pyatv.interface.DeviceInfo">DeviceInfo</a></code></dt>
<dd>
<section class="desc"><p>Return API for device information.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def device_info(self) -&gt; DeviceInfo:
    &#34;&#34;&#34;Return API for device information.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.AppleTV.features"><code class="name">var <span class="ident">features</span> -> <a title="pyatv.interface.Features" href="#pyatv.interface.Features">Features</a></code></dt>
<dd>
<section class="desc"><p>Return features interface.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def features(self) -&gt; Features:
    &#34;&#34;&#34;Return features interface.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.AppleTV.metadata"><code class="name">var <span class="ident">metadata</span> -> <a title="pyatv.interface.Metadata" href="#pyatv.interface.Metadata">Metadata</a></code></dt>
<dd>
<section class="desc"><p>Return API for retrieving metadata from the Apple TV.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def metadata(self) -&gt; Metadata:
    &#34;&#34;&#34;Return API for retrieving metadata from the Apple TV.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.AppleTV.power"><code class="name">var <span class="ident">power</span> -> <a title="pyatv.interface.Power" href="#pyatv.interface.Power">Power</a></code></dt>
<dd>
<section class="desc"><p>Return API for power management.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def power(self) -&gt; Power:
    &#34;&#34;&#34;Return API for power management.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.AppleTV.push_updater"><code class="name">var <span class="ident">push_updater</span> -> <a title="pyatv.interface.PushUpdater" href="#pyatv.interface.PushUpdater">PushUpdater</a></code></dt>
<dd>
<section class="desc"><p>Return API for handling push update from the Apple TV.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def push_updater(self) -&gt; PushUpdater:
    &#34;&#34;&#34;Return API for handling push update from the Apple TV.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.AppleTV.remote_control"><code class="name">var <span class="ident">remote_control</span> -> <a title="pyatv.interface.RemoteControl" href="#pyatv.interface.RemoteControl">RemoteControl</a></code></dt>
<dd>
<section class="desc"><p>Return API for controlling the Apple TV.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def remote_control(self) -&gt; RemoteControl:
    &#34;&#34;&#34;Return API for controlling the Apple TV.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.AppleTV.service"><code class="name">var <span class="ident">service</span> -> <a title="pyatv.interface.BaseService" href="#pyatv.interface.BaseService">BaseService</a></code></dt>
<dd>
<section class="desc"><p>Return service used to connect to the Apple TV.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def service(self) -&gt; BaseService:
    &#34;&#34;&#34;Return service used to connect to the Apple TV.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.AppleTV.stream"><code class="name">var <span class="ident">stream</span> -> <a title="pyatv.interface.Stream" href="#pyatv.interface.Stream">Stream</a></code></dt>
<dd>
<section class="desc"><p>Return API for streaming media.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def stream(self) -&gt; Stream:
    &#34;&#34;&#34;Return API for streaming media.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.AppleTV.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Close connection and release allocated resources.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def close(self) -&gt; None:
    &#34;&#34;&#34;Close connection and release allocated resources.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.AppleTV.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Initiate connection to device.</p>
<p>No need to call it yourself, it's done automatically.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def connect(self) -&gt; None:
    &#34;&#34;&#34;Initiate connection to device.

    No need to call it yourself, it&#39;s done automatically.
    &#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyatv.interface.StateProducer" href="#pyatv.interface.StateProducer">StateProducer</a></b></code>:
<ul class="hlist">
<li><code><a title="pyatv.interface.StateProducer.listener" href="#pyatv.interface.StateProducer.listener">listener</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyatv.interface.ArtworkInfo"><code class="flex name class">
<span>class <span class="ident">ArtworkInfo</span></span>
<span>(</span><span>bytes: bytes, mimetype: str, width: int, height: int)</span>
</code></dt>
<dd>
<section class="desc"><p>Artwork information.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArtworkInfo(NamedTuple):
    &#34;&#34;&#34;Artwork information.&#34;&#34;&#34;

    bytes: bytes
    mimetype: str
    width: int
    height: int</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.ArtworkInfo.bytes"><code class="name">var <span class="ident">bytes</span> -> bytes</code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="pyatv.interface.ArtworkInfo.height"><code class="name">var <span class="ident">height</span> -> int</code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
</dd>
<dt id="pyatv.interface.ArtworkInfo.mimetype"><code class="name">var <span class="ident">mimetype</span> -> str</code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="pyatv.interface.ArtworkInfo.width"><code class="name">var <span class="ident">width</span> -> int</code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.BaseService"><code class="flex name class">
<span>class <span class="ident">BaseService</span></span>
<span>(</span><span>identifier: Optional[str], protocol: <a title="pyatv.const.Protocol" href="const#pyatv.const.Protocol">Protocol</a>, port: int, properties: Optional[Mapping[str, str]])</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for protocol services.</p>
<p>Initialize a new BaseService.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseService:
    &#34;&#34;&#34;Base class for protocol services.&#34;&#34;&#34;

    def __init__(
        self,
        identifier: Optional[str],
        protocol: Protocol,
        port: int,
        properties: Optional[Mapping[str, str]],
    ) -&gt; None:
        &#34;&#34;&#34;Initialize a new BaseService.&#34;&#34;&#34;
        self.__identifier = identifier
        self.protocol = protocol
        self.port = port
        self.credentials: Optional[str] = None
        self.properties: MutableMapping[str, str] = dict(properties or {})

    @property
    def identifier(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Return unique identifier associated with this service.&#34;&#34;&#34;
        return self.__identifier

    def merge(self, other) -&gt; None:
        &#34;&#34;&#34;Merge with other service of same type.&#34;&#34;&#34;
        self.credentials = other.credentials or self.credentials
        self.properties.update(other.properties)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of this object.&#34;&#34;&#34;
        return &#34;Protocol: {0}, Port: {1}, Credentials: {2}&#34;.format(
            convert.protocol_str(self.protocol), self.port, self.credentials
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyatv.conf.AirPlayService" href="conf#pyatv.conf.AirPlayService">AirPlayService</a></li>
<li><a title="pyatv.conf.DmapService" href="conf#pyatv.conf.DmapService">DmapService</a></li>
<li><a title="pyatv.conf.MrpService" href="conf#pyatv.conf.MrpService">MrpService</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.BaseService.identifier"><code class="name">var <span class="ident">identifier</span> -> Optional[str]</code></dt>
<dd>
<section class="desc"><p>Return unique identifier associated with this service.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def identifier(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Return unique identifier associated with this service.&#34;&#34;&#34;
    return self.__identifier</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.BaseService.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, other) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Merge with other service of same type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, other) -&gt; None:
    &#34;&#34;&#34;Merge with other service of same type.&#34;&#34;&#34;
    self.credentials = other.credentials or self.credentials
    self.properties.update(other.properties)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.DeviceInfo"><code class="flex name class">
<span>class <span class="ident">DeviceInfo</span></span>
<span>(</span><span>os: <a title="pyatv.const.OperatingSystem" href="const#pyatv.const.OperatingSystem">OperatingSystem</a>, version: Optional[str], build_number: Optional[str], model: <a title="pyatv.const.DeviceModel" href="const#pyatv.const.DeviceModel">DeviceModel</a>, mac: Optional[str])</span>
</code></dt>
<dd>
<section class="desc"><p>General information about device.</p>
<p>Initialize a new DeviceInfo instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeviceInfo:
    &#34;&#34;&#34;General information about device.&#34;&#34;&#34;

    def __init__(
        self,
        os: const.OperatingSystem,
        version: Optional[str],
        build_number: Optional[str],
        model: const.DeviceModel,
        mac: Optional[str],
    ) -&gt; None:  # pylint: disable=too-many-arguments  # noqa
        &#34;&#34;&#34;Initialize a new DeviceInfo instance.&#34;&#34;&#34;
        self._os = os
        self._version = version
        self._build_number = build_number
        self._model = model
        self._mac = mac

    @property
    def operating_system(self) -&gt; const.OperatingSystem:
        &#34;&#34;&#34;Operating system running on device.&#34;&#34;&#34;
        return self._os

    @property
    def version(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Operating system version.&#34;&#34;&#34;
        return self._version

    @property
    def build_number(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Operating system build number, e.g. 17K795.&#34;&#34;&#34;
        return self._build_number

    @property
    def model(self) -&gt; const.DeviceModel:
        &#34;&#34;&#34;Hardware model name, e.g. 3, 4 or 4K.&#34;&#34;&#34;
        return self._model

    @property
    def mac(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Device MAC address.&#34;&#34;&#34;
        return self._mac

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Convert device info to readable string.&#34;&#34;&#34;
        if self.model != DeviceModel.Unknown:
            output = self.model.name.replace(&#34;Gen&#34;, &#34;&#34;)
        else:
            output = &#34;Unknown Model&#34;

        output += (
            &#34; &#34;
            + {
                OperatingSystem.Legacy: &#34;ATV SW&#34;,
                OperatingSystem.TvOS: &#34;tvOS&#34;,
            }.get(self.operating_system, &#34;Unknown OS&#34;)
        )

        if self.version:
            output += &#34; &#34; + self.version

        if self.build_number:
            output += &#34; build &#34; + self.build_number

        return output</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.DeviceInfo.build_number"><code class="name">var <span class="ident">build_number</span> -> Optional[str]</code></dt>
<dd>
<section class="desc"><p>Operating system build number, e.g. 17K795.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def build_number(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Operating system build number, e.g. 17K795.&#34;&#34;&#34;
    return self._build_number</code></pre>
</details>
</dd>
<dt id="pyatv.interface.DeviceInfo.mac"><code class="name">var <span class="ident">mac</span> -> Optional[str]</code></dt>
<dd>
<section class="desc"><p>Device MAC address.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mac(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Device MAC address.&#34;&#34;&#34;
    return self._mac</code></pre>
</details>
</dd>
<dt id="pyatv.interface.DeviceInfo.model"><code class="name">var <span class="ident">model</span> -> <a title="pyatv.const.DeviceModel" href="const#pyatv.const.DeviceModel">DeviceModel</a></code></dt>
<dd>
<section class="desc"><p>Hardware model name, e.g. 3, 4 or 4K.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self) -&gt; const.DeviceModel:
    &#34;&#34;&#34;Hardware model name, e.g. 3, 4 or 4K.&#34;&#34;&#34;
    return self._model</code></pre>
</details>
</dd>
<dt id="pyatv.interface.DeviceInfo.operating_system"><code class="name">var <span class="ident">operating_system</span> -> <a title="pyatv.const.OperatingSystem" href="const#pyatv.const.OperatingSystem">OperatingSystem</a></code></dt>
<dd>
<section class="desc"><p>Operating system running on device.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def operating_system(self) -&gt; const.OperatingSystem:
    &#34;&#34;&#34;Operating system running on device.&#34;&#34;&#34;
    return self._os</code></pre>
</details>
</dd>
<dt id="pyatv.interface.DeviceInfo.version"><code class="name">var <span class="ident">version</span> -> Optional[str]</code></dt>
<dd>
<section class="desc"><p>Operating system version.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Operating system version.&#34;&#34;&#34;
    return self._version</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.DeviceListener"><code class="flex name class">
<span>class <span class="ident">DeviceListener</span></span>
</code></dt>
<dd>
<section class="desc"><p>Listener interface for generic device updates.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeviceListener(ABC):
    &#34;&#34;&#34;Listener interface for generic device updates.&#34;&#34;&#34;

    @abstractmethod
    def connection_lost(self, exception: Exception) -&gt; None:
        &#34;&#34;&#34;Device was unexpectedly disconnected.&#34;&#34;&#34;
        raise NotImplementedError()

    @abstractmethod
    def connection_closed(self) -&gt; None:
        &#34;&#34;&#34;Device connection was (intentionally) closed.&#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyatv.scripts.atvremote.DeviceListener</li>
<li>pyatv.scripts.atvscript.DevicePrinter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.DeviceListener.connection_closed"><code class="name flex">
<span>def <span class="ident">connection_closed</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Device connection was (intentionally) closed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def connection_closed(self) -&gt; None:
    &#34;&#34;&#34;Device connection was (intentionally) closed.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.DeviceListener.connection_lost"><code class="name flex">
<span>def <span class="ident">connection_lost</span></span>(<span>self, exception: Exception) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Device was unexpectedly disconnected.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def connection_lost(self, exception: Exception) -&gt; None:
    &#34;&#34;&#34;Device was unexpectedly disconnected.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.FeatureInfo"><code class="flex name class">
<span>class <span class="ident">FeatureInfo</span></span>
<span>(</span><span>state: <a title="pyatv.const.FeatureState" href="const#pyatv.const.FeatureState">FeatureState</a>, options: Optional[Dict[str, object]] = {})</span>
</code></dt>
<dd>
<section class="desc"><p>Feature state and options.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureInfo(NamedTuple):
    &#34;&#34;&#34;Feature state and options.&#34;&#34;&#34;

    state: FeatureState
    options: Optional[Dict[str, object]] = {}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.FeatureInfo.options"><code class="name">var <span class="ident">options</span> -> Optional[Dict[str, object]]</code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="pyatv.interface.FeatureInfo.state"><code class="name">var <span class="ident">state</span> -> <a title="pyatv.const.FeatureState" href="const#pyatv.const.FeatureState">FeatureState</a></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.Features"><code class="flex name class">
<span>class <span class="ident">Features</span></span>
</code></dt>
<dd>
<section class="desc"><p>Base class for supported feature functionality.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Features(ABC):
    &#34;&#34;&#34;Base class for supported feature functionality.&#34;&#34;&#34;

    @abstractmethod
    def get_feature(self, feature: FeatureName) -&gt; FeatureInfo:
        &#34;&#34;&#34;Return current state of a feature.&#34;&#34;&#34;
        raise NotImplementedError()

    def all_features(self, include_unsupported=False) -&gt; Dict[FeatureName, FeatureInfo]:
        &#34;&#34;&#34;Return state of all features.&#34;&#34;&#34;
        features = {}  # type: Dict[FeatureName, FeatureInfo]
        for name in FeatureName:
            feature = self.get_feature(name)
            if feature.state != FeatureState.Unsupported or include_unsupported:
                features[name] = feature
        return features

    def in_state(
        self,
        states: Union[List[FeatureState], FeatureState],
        *feature_names: FeatureName
    ):
        &#34;&#34;&#34;Return if features are in a specific state.

        This method will return True if all given features are in the state specified
        by &#34;states&#34;. If &#34;states&#34; is a list of states, it is enough for the feature to be
        in one of the listed states.
        &#34;&#34;&#34;
        for name in feature_names:
            feature = self.get_feature(name)
            expected_states = states if isinstance(states, list) else [states]
            if feature.state not in expected_states:
                return False
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyatv.dmap.DmapFeatures</li>
<li>pyatv.mrp.MrpFeatures</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.Features.all_features"><code class="name flex">
<span>def <span class="ident">all_features</span></span>(<span>self, include_unsupported=False) -> Dict[<a title="pyatv.const.FeatureName" href="const#pyatv.const.FeatureName">FeatureName</a>, <a title="pyatv.interface.FeatureInfo" href="#pyatv.interface.FeatureInfo">FeatureInfo</a>]</span>
</code></dt>
<dd>
<section class="desc"><p>Return state of all features.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_features(self, include_unsupported=False) -&gt; Dict[FeatureName, FeatureInfo]:
    &#34;&#34;&#34;Return state of all features.&#34;&#34;&#34;
    features = {}  # type: Dict[FeatureName, FeatureInfo]
    for name in FeatureName:
        feature = self.get_feature(name)
        if feature.state != FeatureState.Unsupported or include_unsupported:
            features[name] = feature
    return features</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Features.get_feature"><code class="name flex">
<span>def <span class="ident">get_feature</span></span>(<span>self, feature: <a title="pyatv.const.FeatureName" href="const#pyatv.const.FeatureName">FeatureName</a>) -> <a title="pyatv.interface.FeatureInfo" href="#pyatv.interface.FeatureInfo">FeatureInfo</a></span>
</code></dt>
<dd>
<section class="desc"><p>Return current state of a feature.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_feature(self, feature: FeatureName) -&gt; FeatureInfo:
    &#34;&#34;&#34;Return current state of a feature.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Features.in_state"><code class="name flex">
<span>def <span class="ident">in_state</span></span>(<span>self, states: Union[List[<a title="pyatv.const.FeatureState" href="const#pyatv.const.FeatureState">FeatureState</a>], <a title="pyatv.const.FeatureState" href="const#pyatv.const.FeatureState">FeatureState</a>], *feature_names: <a title="pyatv.const.FeatureName" href="const#pyatv.const.FeatureName">FeatureName</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return if features are in a specific state.</p>
<p>This method will return True if all given features are in the state specified
by "states". If "states" is a list of states, it is enough for the feature to be
in one of the listed states.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_state(
    self,
    states: Union[List[FeatureState], FeatureState],
    *feature_names: FeatureName
):
    &#34;&#34;&#34;Return if features are in a specific state.

    This method will return True if all given features are in the state specified
    by &#34;states&#34;. If &#34;states&#34; is a list of states, it is enough for the feature to be
    in one of the listed states.
    &#34;&#34;&#34;
    for name in feature_names:
        feature = self.get_feature(name)
        expected_states = states if isinstance(states, list) else [states]
        if feature.state not in expected_states:
            return False
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.Metadata"><code class="flex name class">
<span>class <span class="ident">Metadata</span></span>
<span>(</span><span>identifier: str)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for retrieving metadata from an Apple TV.</p>
<p>Initialize a new instance of Metadata.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Metadata(ABC):
    &#34;&#34;&#34;Base class for retrieving metadata from an Apple TV.&#34;&#34;&#34;

    def __init__(self, identifier: str) -&gt; None:
        &#34;&#34;&#34;Initialize a new instance of Metadata.&#34;&#34;&#34;
        self._identifier = identifier

    @property
    def device_id(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Return a unique identifier for current device.&#34;&#34;&#34;
        return self._identifier

    @abstractmethod
    @feature(30, &#34;Artwork&#34;, &#34;Playing media artwork.&#34;)
    async def artwork(self, width=512, height=None) -&gt; Optional[ArtworkInfo]:
        &#34;&#34;&#34;Return artwork for what is currently playing (or None).

        The parameters &#34;width&#34; and &#34;height&#34; makes it possible to request artwork of a
        specific size. This is just a request, the device might impose restrictions and
        return artwork of a different size. Set both parameters to None to request
        default size. Set one of them and let the other one be None to keep original
        aspect ratio.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def artwork_id(self) -&gt; str:
        &#34;&#34;&#34;Return a unique identifier for current artwork.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    async def playing(self) -&gt; Playing:
        &#34;&#34;&#34;Return what is currently playing.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property  # type: ignore
    @abstractmethod
    @feature(35, &#34;App&#34;, &#34;App playing media.&#34;)
    def app(self) -&gt; Optional[App]:
        &#34;&#34;&#34;Return information about current app playing something.

        Do note that this property returns which app is currently playing something and
        not which app is currently active. If nothing is playing, the corresponding
        feature will be unavailable.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyatv.dmap.DmapMetadata</li>
<li>pyatv.mrp.MrpMetadata</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.Metadata.app"><code class="name">var <span class="ident">app</span> -> Optional[<a title="pyatv.interface.App" href="#pyatv.interface.App">App</a>]</code></dt>
<dd>
<section class="desc"><p>Return information about current app playing something.</p>
<p>Do note that this property returns which app is currently playing something and
not which app is currently active. If nothing is playing, the corresponding
feature will be unavailable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # type: ignore
@abstractmethod
@feature(35, &#34;App&#34;, &#34;App playing media.&#34;)
def app(self) -&gt; Optional[App]:
    &#34;&#34;&#34;Return information about current app playing something.

    Do note that this property returns which app is currently playing something and
    not which app is currently active. If nothing is playing, the corresponding
    feature will be unavailable.
    &#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Metadata.artwork_id"><code class="name">var <span class="ident">artwork_id</span> -> str</code></dt>
<dd>
<section class="desc"><p>Return a unique identifier for current artwork.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def artwork_id(self) -&gt; str:
    &#34;&#34;&#34;Return a unique identifier for current artwork.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Metadata.device_id"><code class="name">var <span class="ident">device_id</span> -> Optional[str]</code></dt>
<dd>
<section class="desc"><p>Return a unique identifier for current device.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def device_id(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Return a unique identifier for current device.&#34;&#34;&#34;
    return self._identifier</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.Metadata.artwork"><code class="name flex">
<span>async def <span class="ident">artwork</span></span>(<span>self, width=512, height=None) -> Optional[<a title="pyatv.interface.ArtworkInfo" href="#pyatv.interface.ArtworkInfo">ArtworkInfo</a>]</span>
</code></dt>
<dd>
<section class="desc"><p>Return artwork for what is currently playing (or None).</p>
<p>The parameters "width" and "height" makes it possible to request artwork of a
specific size. This is just a request, the device might impose restrictions and
return artwork of a different size. Set both parameters to None to request
default size. Set one of them and let the other one be None to keep original
aspect ratio.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(30, &#34;Artwork&#34;, &#34;Playing media artwork.&#34;)
async def artwork(self, width=512, height=None) -&gt; Optional[ArtworkInfo]:
    &#34;&#34;&#34;Return artwork for what is currently playing (or None).

    The parameters &#34;width&#34; and &#34;height&#34; makes it possible to request artwork of a
    specific size. This is just a request, the device might impose restrictions and
    return artwork of a different size. Set both parameters to None to request
    default size. Set one of them and let the other one be None to keep original
    aspect ratio.
    &#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Metadata.playing"><code class="name flex">
<span>async def <span class="ident">playing</span></span>(<span>self) -> <a title="pyatv.interface.Playing" href="#pyatv.interface.Playing">Playing</a></span>
</code></dt>
<dd>
<section class="desc"><p>Return what is currently playing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def playing(self) -&gt; Playing:
    &#34;&#34;&#34;Return what is currently playing.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.PairingHandler"><code class="flex name class">
<span>class <span class="ident">PairingHandler</span></span>
<span>(</span><span>session_manager: pyatv.support.net.ClientSessionManager, service: <a title="pyatv.interface.BaseService" href="#pyatv.interface.BaseService">BaseService</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for API used to pair with an Apple TV.</p>
<p>Initialize a new instance of PairingHandler.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PairingHandler(ABC):
    &#34;&#34;&#34;Base class for API used to pair with an Apple TV.&#34;&#34;&#34;

    def __init__(
        self, session_manager: net.ClientSessionManager, service: BaseService
    ) -&gt; None:
        &#34;&#34;&#34;Initialize a new instance of PairingHandler.&#34;&#34;&#34;
        self.session_manager = session_manager
        self._service = service

    @property
    def service(self) -&gt; BaseService:
        &#34;&#34;&#34;Return service used for pairing.&#34;&#34;&#34;
        return self._service

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Call to free allocated resources after pairing.&#34;&#34;&#34;
        await self.session_manager.close()

    @abstractmethod
    def pin(self, pin) -&gt; None:
        &#34;&#34;&#34;Pin code used for pairing.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def device_provides_pin(self) -&gt; bool:
        &#34;&#34;&#34;Return True if remote device presents PIN code, else False.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @property
    @abstractmethod
    def has_paired(self) -&gt; bool:
        &#34;&#34;&#34;If a successful pairing has been performed.

        The value will be reset when stop() is called.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    async def begin(self) -&gt; None:
        &#34;&#34;&#34;Start pairing process.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    async def finish(self) -&gt; None:
        &#34;&#34;&#34;Stop pairing process.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyatv.airplay.pairing.AirPlayPairingHandler</li>
<li>pyatv.dmap.pairing.DmapPairingHandler</li>
<li>pyatv.mrp.pairing.MrpPairingHandler</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.PairingHandler.device_provides_pin"><code class="name">var <span class="ident">device_provides_pin</span> -> bool</code></dt>
<dd>
<section class="desc"><p>Return True if remote device presents PIN code, else False.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def device_provides_pin(self) -&gt; bool:
    &#34;&#34;&#34;Return True if remote device presents PIN code, else False.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.PairingHandler.has_paired"><code class="name">var <span class="ident">has_paired</span> -> bool</code></dt>
<dd>
<section class="desc"><p>If a successful pairing has been performed.</p>
<p>The value will be reset when stop() is called.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def has_paired(self) -&gt; bool:
    &#34;&#34;&#34;If a successful pairing has been performed.

    The value will be reset when stop() is called.
    &#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.PairingHandler.service"><code class="name">var <span class="ident">service</span> -> <a title="pyatv.interface.BaseService" href="#pyatv.interface.BaseService">BaseService</a></code></dt>
<dd>
<section class="desc"><p>Return service used for pairing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def service(self) -&gt; BaseService:
    &#34;&#34;&#34;Return service used for pairing.&#34;&#34;&#34;
    return self._service</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.PairingHandler.begin"><code class="name flex">
<span>async def <span class="ident">begin</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Start pairing process.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def begin(self) -&gt; None:
    &#34;&#34;&#34;Start pairing process.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.PairingHandler.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Call to free allocated resources after pairing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    &#34;&#34;&#34;Call to free allocated resources after pairing.&#34;&#34;&#34;
    await self.session_manager.close()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.PairingHandler.finish"><code class="name flex">
<span>async def <span class="ident">finish</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Stop pairing process.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
async def finish(self) -&gt; None:
    &#34;&#34;&#34;Stop pairing process.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.PairingHandler.pin"><code class="name flex">
<span>def <span class="ident">pin</span></span>(<span>self, pin) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Pin code used for pairing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def pin(self, pin) -&gt; None:
    &#34;&#34;&#34;Pin code used for pairing.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.Playing"><code class="flex name class">
<span>class <span class="ident">Playing</span></span>
<span>(</span><span>media_type: <a title="pyatv.const.MediaType" href="const#pyatv.const.MediaType">MediaType</a> = MediaType.Unknown, device_state: <a title="pyatv.const.DeviceState" href="const#pyatv.const.DeviceState">DeviceState</a> = DeviceState.Idle, title: Optional[str] = None, artist: Optional[str] = None, album: Optional[str] = None, genre: Optional[str] = None, total_time: Optional[int] = None, position: Optional[int] = None, shuffle: Optional[<a title="pyatv.const.ShuffleState" href="const#pyatv.const.ShuffleState">ShuffleState</a>] = None, repeat: Optional[<a title="pyatv.const.RepeatState" href="const#pyatv.const.RepeatState">RepeatState</a>] = None, hash: Optional[str] = None)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for retrieving what is currently playing.</p>
<p>Initialize a new Playing instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Playing(ABC):
    &#34;&#34;&#34;Base class for retrieving what is currently playing.&#34;&#34;&#34;

    _PROPERTIES = [
        &#34;media_type&#34;,
        &#34;device_state&#34;,
        &#34;title&#34;,
        &#34;artist&#34;,
        &#34;album&#34;,
        &#34;genre&#34;,
        &#34;total_time&#34;,
        &#34;position&#34;,
        &#34;shuffle&#34;,
        &#34;repeat&#34;,
        &#34;hash&#34;,
    ]

    def __init__(
        self,
        media_type: const.MediaType = const.MediaType.Unknown,
        device_state: const.DeviceState = const.DeviceState.Idle,
        title: Optional[str] = None,
        artist: Optional[str] = None,
        album: Optional[str] = None,
        genre: Optional[str] = None,
        total_time: Optional[int] = None,
        position: Optional[int] = None,
        shuffle: Optional[const.ShuffleState] = None,
        repeat: Optional[const.RepeatState] = None,
        hash: Optional[str] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize a new Playing instance.&#34;&#34;&#34;
        self._media_type = media_type
        self._device_state = device_state
        self._title = title
        self._artist = artist
        self._album = album
        self._genre = genre
        self._total_time = total_time
        self._position = position
        self._shuffle = shuffle
        self._repeat = repeat
        self._hash = hash

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Convert this playing object to a readable string.&#34;&#34;&#34;
        output = []
        output.append(
            &#34;  Media type: {0}&#34;.format(convert.media_type_str(self.media_type))
        )
        output.append(
            &#34;Device state: {0}&#34;.format(convert.device_state_str(self.device_state))
        )

        if self.title is not None:
            output.append(&#34;       Title: {0}&#34;.format(self.title))

        if self.artist is not None:
            output.append(&#34;      Artist: {0}&#34;.format(self.artist))

        if self.album is not None:
            output.append(&#34;       Album: {0}&#34;.format(self.album))

        if self.genre is not None:
            output.append(&#34;       Genre: {0}&#34;.format(self.genre))

        position = self.position
        total_time = self.total_time
        if position is not None and total_time is not None and total_time != 0:
            output.append(
                &#34;    Position: {0}/{1}s ({2:.1%})&#34;.format(
                    position, total_time, float(position) / float(total_time)
                )
            )
        elif position is not None and position != 0:
            output.append(&#34;    Position: {0}s&#34;.format(position))
        elif total_time is not None and position != 0:
            output.append(&#34;  Total time: {0}s&#34;.format(total_time))

        if self.repeat is not None:
            output.append(&#34;      Repeat: {0}&#34;.format(convert.repeat_str(self.repeat)))

        if self.shuffle is not None:
            output.append(&#34;     Shuffle: {0}&#34;.format(convert.shuffle_str(self.shuffle)))

        return &#34;\n&#34;.join(output)

    def __eq__(self, other):
        &#34;&#34;&#34;Compare if two objects are equal.&#34;&#34;&#34;
        if isinstance(other, Playing):
            for prop in self._PROPERTIES:
                if getattr(self, prop) != getattr(other, prop):
                    return False
            return True
        return False

    @property
    def hash(self) -&gt; str:
        &#34;&#34;&#34;Create a unique hash for what is currently playing.

        The hash is based on title, artist, album and total time. It should
        always be the same for the same content, but it is not guaranteed.
        &#34;&#34;&#34;
        if self._hash:
            return self._hash

        base = &#34;{0}{1}{2}{3}&#34;.format(
            self.title, self.artist, self.album, self.total_time
        )
        return hashlib.sha256(base.encode(&#34;utf-8&#34;)).hexdigest()

    @property
    def media_type(self) -&gt; const.MediaType:
        &#34;&#34;&#34;Type of media is currently playing, e.g. video, music.&#34;&#34;&#34;
        return self._media_type

    @property
    def device_state(self) -&gt; const.DeviceState:
        &#34;&#34;&#34;Device state, e.g. playing or paused.&#34;&#34;&#34;
        return self._device_state

    @property  # type: ignore
    @feature(22, &#34;Title&#34;, &#34;Title of playing media.&#34;)
    def title(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Title of the current media, e.g. movie or song name.&#34;&#34;&#34;
        return self._title

    @property  # type: ignore
    @feature(23, &#34;Artist&#34;, &#34;Artist of playing song.&#34;)
    def artist(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Artist of the currently playing song.&#34;&#34;&#34;
        return self._artist

    @property  # type: ignore
    @feature(24, &#34;Album&#34;, &#34;Album from playing artist.&#34;)
    def album(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Album of the currently playing song.&#34;&#34;&#34;
        return self._album

    @property  # type: ignore
    @feature(25, &#34;Genre&#34;, &#34;Genre of playing song.&#34;)
    def genre(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Genre of the currently playing song.&#34;&#34;&#34;
        return self._genre

    @property  # type: ignore
    @feature(26, &#34;TotalTime&#34;, &#34;Total length of playing media (seconds).&#34;)
    def total_time(self) -&gt; Optional[int]:
        &#34;&#34;&#34;Total play time in seconds.&#34;&#34;&#34;
        return self._total_time

    @property  # type: ignore
    @feature(27, &#34;Position&#34;, &#34;Current play time position.&#34;)
    def position(self) -&gt; Optional[int]:
        &#34;&#34;&#34;Position in the playing media (seconds).&#34;&#34;&#34;
        return self._position

    @property  # type: ignore
    @feature(28, &#34;Shuffle&#34;, &#34;Shuffle state.&#34;)
    def shuffle(self) -&gt; Optional[const.ShuffleState]:
        &#34;&#34;&#34;If shuffle is enabled or not.&#34;&#34;&#34;
        return self._shuffle

    @property  # type: ignore
    @feature(29, &#34;Repeat&#34;, &#34;Repeat state.&#34;)
    def repeat(self) -&gt; Optional[const.RepeatState]:
        &#34;&#34;&#34;Repeat mode.&#34;&#34;&#34;
        return self._repeat</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.Playing.album"><code class="name">var <span class="ident">album</span> -> Optional[str]</code></dt>
<dd>
<section class="desc"><p>Album of the currently playing song.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # type: ignore
@feature(24, &#34;Album&#34;, &#34;Album from playing artist.&#34;)
def album(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Album of the currently playing song.&#34;&#34;&#34;
    return self._album</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Playing.artist"><code class="name">var <span class="ident">artist</span> -> Optional[str]</code></dt>
<dd>
<section class="desc"><p>Artist of the currently playing song.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # type: ignore
@feature(23, &#34;Artist&#34;, &#34;Artist of playing song.&#34;)
def artist(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Artist of the currently playing song.&#34;&#34;&#34;
    return self._artist</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Playing.device_state"><code class="name">var <span class="ident">device_state</span> -> <a title="pyatv.const.DeviceState" href="const#pyatv.const.DeviceState">DeviceState</a></code></dt>
<dd>
<section class="desc"><p>Device state, e.g. playing or paused.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def device_state(self) -&gt; const.DeviceState:
    &#34;&#34;&#34;Device state, e.g. playing or paused.&#34;&#34;&#34;
    return self._device_state</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Playing.genre"><code class="name">var <span class="ident">genre</span> -> Optional[str]</code></dt>
<dd>
<section class="desc"><p>Genre of the currently playing song.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # type: ignore
@feature(25, &#34;Genre&#34;, &#34;Genre of playing song.&#34;)
def genre(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Genre of the currently playing song.&#34;&#34;&#34;
    return self._genre</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Playing.hash"><code class="name">var <span class="ident">hash</span> -> str</code></dt>
<dd>
<section class="desc"><p>Create a unique hash for what is currently playing.</p>
<p>The hash is based on title, artist, album and total time. It should
always be the same for the same content, but it is not guaranteed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hash(self) -&gt; str:
    &#34;&#34;&#34;Create a unique hash for what is currently playing.

    The hash is based on title, artist, album and total time. It should
    always be the same for the same content, but it is not guaranteed.
    &#34;&#34;&#34;
    if self._hash:
        return self._hash

    base = &#34;{0}{1}{2}{3}&#34;.format(
        self.title, self.artist, self.album, self.total_time
    )
    return hashlib.sha256(base.encode(&#34;utf-8&#34;)).hexdigest()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Playing.media_type"><code class="name">var <span class="ident">media_type</span> -> <a title="pyatv.const.MediaType" href="const#pyatv.const.MediaType">MediaType</a></code></dt>
<dd>
<section class="desc"><p>Type of media is currently playing, e.g. video, music.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def media_type(self) -&gt; const.MediaType:
    &#34;&#34;&#34;Type of media is currently playing, e.g. video, music.&#34;&#34;&#34;
    return self._media_type</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Playing.position"><code class="name">var <span class="ident">position</span> -> Optional[int]</code></dt>
<dd>
<section class="desc"><p>Position in the playing media (seconds).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # type: ignore
@feature(27, &#34;Position&#34;, &#34;Current play time position.&#34;)
def position(self) -&gt; Optional[int]:
    &#34;&#34;&#34;Position in the playing media (seconds).&#34;&#34;&#34;
    return self._position</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Playing.repeat"><code class="name">var <span class="ident">repeat</span> -> Optional[<a title="pyatv.const.RepeatState" href="const#pyatv.const.RepeatState">RepeatState</a>]</code></dt>
<dd>
<section class="desc"><p>Repeat mode.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # type: ignore
@feature(29, &#34;Repeat&#34;, &#34;Repeat state.&#34;)
def repeat(self) -&gt; Optional[const.RepeatState]:
    &#34;&#34;&#34;Repeat mode.&#34;&#34;&#34;
    return self._repeat</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Playing.shuffle"><code class="name">var <span class="ident">shuffle</span> -> Optional[<a title="pyatv.const.ShuffleState" href="const#pyatv.const.ShuffleState">ShuffleState</a>]</code></dt>
<dd>
<section class="desc"><p>If shuffle is enabled or not.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # type: ignore
@feature(28, &#34;Shuffle&#34;, &#34;Shuffle state.&#34;)
def shuffle(self) -&gt; Optional[const.ShuffleState]:
    &#34;&#34;&#34;If shuffle is enabled or not.&#34;&#34;&#34;
    return self._shuffle</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Playing.title"><code class="name">var <span class="ident">title</span> -> Optional[str]</code></dt>
<dd>
<section class="desc"><p>Title of the current media, e.g. movie or song name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # type: ignore
@feature(22, &#34;Title&#34;, &#34;Title of playing media.&#34;)
def title(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Title of the current media, e.g. movie or song name.&#34;&#34;&#34;
    return self._title</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Playing.total_time"><code class="name">var <span class="ident">total_time</span> -> Optional[int]</code></dt>
<dd>
<section class="desc"><p>Total play time in seconds.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # type: ignore
@feature(26, &#34;TotalTime&#34;, &#34;Total length of playing media (seconds).&#34;)
def total_time(self) -&gt; Optional[int]:
    &#34;&#34;&#34;Total play time in seconds.&#34;&#34;&#34;
    return self._total_time</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.Power"><code class="flex name class">
<span>class <span class="ident">Power</span></span>
</code></dt>
<dd>
<section class="desc"><p>Base class for retrieving power state from an Apple TV.</p>
<p>Listener interface: <code>pyatv.interfaces.PowerListener</code></p>
<p>Initialize a new StateProducer instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Power(ABC, StateProducer):
    &#34;&#34;&#34;Base class for retrieving power state from an Apple TV.

    Listener interface: `pyatv.interfaces.PowerListener`
    &#34;&#34;&#34;

    @property  # type: ignore
    @abstractmethod
    @feature(32, &#34;PowerState&#34;, &#34;Current device power state.&#34;)
    def power_state(self) -&gt; const.PowerState:
        &#34;&#34;&#34;Return device power state.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(33, &#34;TurnOn&#34;, &#34;Turn device on.&#34;)
    async def turn_on(self, await_new_state: bool = False) -&gt; None:
        &#34;&#34;&#34;Turn device on.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(34, &#34;TurnOff&#34;, &#34;Turn off device.&#34;)
    async def turn_off(self, await_new_state: bool = False) -&gt; None:
        &#34;&#34;&#34;Turn device off.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
<li><a title="pyatv.interface.StateProducer" href="#pyatv.interface.StateProducer">StateProducer</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyatv.dmap.DmapPower</li>
<li>pyatv.mrp.MrpPower</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.Power.power_state"><code class="name">var <span class="ident">power_state</span> -> <a title="pyatv.const.PowerState" href="const#pyatv.const.PowerState">PowerState</a></code></dt>
<dd>
<section class="desc"><p>Return device power state.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # type: ignore
@abstractmethod
@feature(32, &#34;PowerState&#34;, &#34;Current device power state.&#34;)
def power_state(self) -&gt; const.PowerState:
    &#34;&#34;&#34;Return device power state.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.Power.turn_off"><code class="name flex">
<span>async def <span class="ident">turn_off</span></span>(<span>self, await_new_state: bool = False) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Turn device off.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(34, &#34;TurnOff&#34;, &#34;Turn off device.&#34;)
async def turn_off(self, await_new_state: bool = False) -&gt; None:
    &#34;&#34;&#34;Turn device off.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Power.turn_on"><code class="name flex">
<span>async def <span class="ident">turn_on</span></span>(<span>self, await_new_state: bool = False) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Turn device on.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(33, &#34;TurnOn&#34;, &#34;Turn device on.&#34;)
async def turn_on(self, await_new_state: bool = False) -&gt; None:
    &#34;&#34;&#34;Turn device on.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyatv.interface.StateProducer" href="#pyatv.interface.StateProducer">StateProducer</a></b></code>:
<ul class="hlist">
<li><code><a title="pyatv.interface.StateProducer.listener" href="#pyatv.interface.StateProducer.listener">listener</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyatv.interface.PowerListener"><code class="flex name class">
<span>class <span class="ident">PowerListener</span></span>
</code></dt>
<dd>
<section class="desc"><p>Listener interface for power updates.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PowerListener(ABC):  # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Listener interface for power updates.&#34;&#34;&#34;

    @abstractmethod
    def powerstate_update(
        self, old_state: const.PowerState, new_state: const.PowerState
    ):
        &#34;&#34;&#34;Device power state was updated.&#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyatv.scripts.atvscript.PowerPrinter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.PowerListener.powerstate_update"><code class="name flex">
<span>def <span class="ident">powerstate_update</span></span>(<span>self, old_state: <a title="pyatv.const.PowerState" href="const#pyatv.const.PowerState">PowerState</a>, new_state: <a title="pyatv.const.PowerState" href="const#pyatv.const.PowerState">PowerState</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>Device power state was updated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def powerstate_update(
    self, old_state: const.PowerState, new_state: const.PowerState
):
    &#34;&#34;&#34;Device power state was updated.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.PushListener"><code class="flex name class">
<span>class <span class="ident">PushListener</span></span>
</code></dt>
<dd>
<section class="desc"><p>Listener interface for push updates.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PushListener(ABC):
    &#34;&#34;&#34;Listener interface for push updates.&#34;&#34;&#34;

    @abstractmethod
    def playstatus_update(self, updater, playstatus: Playing) -&gt; None:
        &#34;&#34;&#34;Inform about changes to what is currently playing.&#34;&#34;&#34;

    @abstractmethod
    def playstatus_error(self, updater, exception: Exception) -&gt; None:
        &#34;&#34;&#34;Inform about an error when updating play status.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyatv.scripts.atvremote.PushListener</li>
<li>pyatv.scripts.atvscript.PushPrinter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.PushListener.playstatus_error"><code class="name flex">
<span>def <span class="ident">playstatus_error</span></span>(<span>self, updater, exception: Exception) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Inform about an error when updating play status.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def playstatus_error(self, updater, exception: Exception) -&gt; None:
    &#34;&#34;&#34;Inform about an error when updating play status.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="pyatv.interface.PushListener.playstatus_update"><code class="name flex">
<span>def <span class="ident">playstatus_update</span></span>(<span>self, updater, playstatus: <a title="pyatv.interface.Playing" href="#pyatv.interface.Playing">Playing</a>) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Inform about changes to what is currently playing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def playstatus_update(self, updater, playstatus: Playing) -&gt; None:
    &#34;&#34;&#34;Inform about changes to what is currently playing.&#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.PushUpdater"><code class="flex name class">
<span>class <span class="ident">PushUpdater</span></span>
<span>(</span><span>loop: asyncio.events.AbstractEventLoop)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for push/async updates from an Apple TV.</p>
<p>Listener interface: <code><a title="pyatv.interface.PushListener" href="#pyatv.interface.PushListener">PushListener</a></code></p>
<p>Initialize a new PushUpdater.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PushUpdater(ABC, StateProducer):
    &#34;&#34;&#34;Base class for push/async updates from an Apple TV.

    Listener interface: `pyatv.interface.PushListener`
    &#34;&#34;&#34;

    def __init__(self, loop: asyncio.AbstractEventLoop):
        &#34;&#34;&#34;Initialize a new PushUpdater.&#34;&#34;&#34;
        self.loop = loop
        self._previous_state: Optional[Playing] = None

    @property
    @abstractmethod
    def active(self) -&gt; bool:
        &#34;&#34;&#34;Return if push updater has been started.&#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def start(self, initial_delay: int = 0) -&gt; None:
        &#34;&#34;&#34;Begin to listen to updates.

        If an error occurs, start must be called again.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def stop(self) -&gt; None:
        &#34;&#34;&#34;No longer forward updates to listener.&#34;&#34;&#34;
        raise NotImplementedError

    def post_update(self, playing: Playing) -&gt; None:
        &#34;&#34;&#34;Post an update to listener.&#34;&#34;&#34;
        if playing != self._previous_state:
            self.loop.call_soon(self.listener.playstatus_update, self, playing)

        self._previous_state = playing</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
<li><a title="pyatv.interface.StateProducer" href="#pyatv.interface.StateProducer">StateProducer</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyatv.dmap.DmapPushUpdater</li>
<li>pyatv.mrp.MrpPushUpdater</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.PushUpdater.active"><code class="name">var <span class="ident">active</span> -> bool</code></dt>
<dd>
<section class="desc"><p>Return if push updater has been started.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def active(self) -&gt; bool:
    &#34;&#34;&#34;Return if push updater has been started.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.PushUpdater.post_update"><code class="name flex">
<span>def <span class="ident">post_update</span></span>(<span>self, playing: <a title="pyatv.interface.Playing" href="#pyatv.interface.Playing">Playing</a>) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Post an update to listener.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_update(self, playing: Playing) -&gt; None:
    &#34;&#34;&#34;Post an update to listener.&#34;&#34;&#34;
    if playing != self._previous_state:
        self.loop.call_soon(self.listener.playstatus_update, self, playing)

    self._previous_state = playing</code></pre>
</details>
</dd>
<dt id="pyatv.interface.PushUpdater.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self, initial_delay: int = 0) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Begin to listen to updates.</p>
<p>If an error occurs, start must be called again.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def start(self, initial_delay: int = 0) -&gt; None:
    &#34;&#34;&#34;Begin to listen to updates.

    If an error occurs, start must be called again.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="pyatv.interface.PushUpdater.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>No longer forward updates to listener.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def stop(self) -&gt; None:
    &#34;&#34;&#34;No longer forward updates to listener.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyatv.interface.StateProducer" href="#pyatv.interface.StateProducer">StateProducer</a></b></code>:
<ul class="hlist">
<li><code><a title="pyatv.interface.StateProducer.listener" href="#pyatv.interface.StateProducer.listener">listener</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyatv.interface.RemoteControl"><code class="flex name class">
<span>class <span class="ident">RemoteControl</span></span>
</code></dt>
<dd>
<section class="desc"><p>Base class for API used to control an Apple TV.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RemoteControl(ABC):  # pylint: disable=too-many-public-methods
    &#34;&#34;&#34;Base class for API used to control an Apple TV.&#34;&#34;&#34;

    # pylint: disable=invalid-name
    @abstractmethod
    @feature(0, &#34;Up&#34;, &#34;Up button on remote.&#34;)
    async def up(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key up.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(1, &#34;Down&#34;, &#34;Down button on remote.&#34;)
    async def down(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key down.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(2, &#34;Left&#34;, &#34;Left button on remote.&#34;)
    async def left(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key left.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(3, &#34;Right&#34;, &#34;Right button on remote.&#34;)
    async def right(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key right.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(4, &#34;Play&#34;, &#34;Start playing media.&#34;)
    async def play(self) -&gt; None:
        &#34;&#34;&#34;Press key play.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(5, &#34;PlayPause&#34;, &#34;Toggle between play/pause.&#34;)
    async def play_pause(self) -&gt; None:
        &#34;&#34;&#34;Toggle between play and pause.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(6, &#34;Pause&#34;, &#34;Pause playing media.&#34;)
    async def pause(self) -&gt; None:
        &#34;&#34;&#34;Press key play.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(7, &#34;Stop&#34;, &#34;Stop playing media.&#34;)
    async def stop(self) -&gt; None:
        &#34;&#34;&#34;Press key stop.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(8, &#34;Next&#34;, &#34;Change to next item.&#34;)
    async def next(self) -&gt; None:
        &#34;&#34;&#34;Press key next.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(9, &#34;Previous&#34;, &#34;Change to previous item.&#34;)
    async def previous(self) -&gt; None:
        &#34;&#34;&#34;Press key previous.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(10, &#34;Select&#34;, &#34;Select current option.&#34;)
    async def select(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key select.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(11, &#34;Menu&#34;, &#34;Go back to previous menu.&#34;)
    async def menu(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key menu.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(12, &#34;VolumeUp&#34;, &#34;Increase volume.&#34;)
    async def volume_up(self) -&gt; None:
        &#34;&#34;&#34;Press key volume up.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(13, &#34;VolumeDown&#34;, &#34;Decrease volume.&#34;)
    async def volume_down(self) -&gt; None:
        &#34;&#34;&#34;Press key volume down.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(14, &#34;Home&#34;, &#34;Home/TV button.&#34;)
    async def home(self, action: InputAction = InputAction.SingleTap) -&gt; None:
        &#34;&#34;&#34;Press key home.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(
        15, &#34;HomeHold&#34;, &#34;Long-press home button (deprecated: use RemoteControl.home).&#34;
    )
    async def home_hold(self) -&gt; None:
        &#34;&#34;&#34;Hold key home.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(16, &#34;TopMenu&#34;, &#34;Go to main menu.&#34;)
    async def top_menu(self) -&gt; None:
        &#34;&#34;&#34;Go to main menu (long press menu).&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(17, &#34;Suspend&#34;, &#34;Suspend device (deprecated; use Power.turn_off).&#34;)
    async def suspend(self) -&gt; None:
        &#34;&#34;&#34;Suspend the device.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(18, &#34;WakeUp&#34;, &#34;Wake up device (deprecated; use Power.turn_on).&#34;)
    async def wakeup(self) -&gt; None:
        &#34;&#34;&#34;Wake up the device.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(
        36,
        &#34;SkipForward&#34;,
        &#34;Skip forward a time interval.&#34;,
    )
    async def skip_forward(self) -&gt; None:
        &#34;&#34;&#34;Skip forward a time interval.

        Skip interval is typically 15-30s, but is decided by the app.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(37, &#34;SkipBackward&#34;, &#34;Skip backwards a time interval.&#34;)
    async def skip_backward(self) -&gt; None:
        &#34;&#34;&#34;Skip backwards a time interval.

        Skip interval is typically 15-30s, but is decided by the app.
        &#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(19, &#34;SetPosition&#34;, &#34;Seek to position.&#34;)
    async def set_position(self, pos: int) -&gt; None:
        &#34;&#34;&#34;Seek in the current playing media.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(20, &#34;SetShuffle&#34;, &#34;Change shuffle state.&#34;)
    async def set_shuffle(self, shuffle_state: const.ShuffleState) -&gt; None:
        &#34;&#34;&#34;Change shuffle mode to on or off.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(21, &#34;SetRepeat&#34;, &#34;Change repeat state.&#34;)
    async def set_repeat(self, repeat_state: const.RepeatState) -&gt; None:
        &#34;&#34;&#34;Change repeat state.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyatv.dmap.DmapRemoteControl</li>
<li>pyatv.mrp.MrpRemoteControl</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.RemoteControl.down"><code class="name flex">
<span>async def <span class="ident">down</span></span>(<span>self, action: <a title="pyatv.const.InputAction" href="const#pyatv.const.InputAction">InputAction</a> = InputAction.SingleTap) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key down.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(1, &#34;Down&#34;, &#34;Down button on remote.&#34;)
async def down(self, action: InputAction = InputAction.SingleTap) -&gt; None:
    &#34;&#34;&#34;Press key down.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.home"><code class="name flex">
<span>async def <span class="ident">home</span></span>(<span>self, action: <a title="pyatv.const.InputAction" href="const#pyatv.const.InputAction">InputAction</a> = InputAction.SingleTap) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key home.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(14, &#34;Home&#34;, &#34;Home/TV button.&#34;)
async def home(self, action: InputAction = InputAction.SingleTap) -&gt; None:
    &#34;&#34;&#34;Press key home.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.home_hold"><code class="name flex">
<span>async def <span class="ident">home_hold</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Hold key home.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(
    15, &#34;HomeHold&#34;, &#34;Long-press home button (deprecated: use RemoteControl.home).&#34;
)
async def home_hold(self) -&gt; None:
    &#34;&#34;&#34;Hold key home.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.left"><code class="name flex">
<span>async def <span class="ident">left</span></span>(<span>self, action: <a title="pyatv.const.InputAction" href="const#pyatv.const.InputAction">InputAction</a> = InputAction.SingleTap) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(2, &#34;Left&#34;, &#34;Left button on remote.&#34;)
async def left(self, action: InputAction = InputAction.SingleTap) -&gt; None:
    &#34;&#34;&#34;Press key left.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.menu"><code class="name flex">
<span>async def <span class="ident">menu</span></span>(<span>self, action: <a title="pyatv.const.InputAction" href="const#pyatv.const.InputAction">InputAction</a> = InputAction.SingleTap) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key menu.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(11, &#34;Menu&#34;, &#34;Go back to previous menu.&#34;)
async def menu(self, action: InputAction = InputAction.SingleTap) -&gt; None:
    &#34;&#34;&#34;Press key menu.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.next"><code class="name flex">
<span>async def <span class="ident">next</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key next.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(8, &#34;Next&#34;, &#34;Change to next item.&#34;)
async def next(self) -&gt; None:
    &#34;&#34;&#34;Press key next.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.pause"><code class="name flex">
<span>async def <span class="ident">pause</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key play.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(6, &#34;Pause&#34;, &#34;Pause playing media.&#34;)
async def pause(self) -&gt; None:
    &#34;&#34;&#34;Press key play.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.play"><code class="name flex">
<span>async def <span class="ident">play</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key play.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(4, &#34;Play&#34;, &#34;Start playing media.&#34;)
async def play(self) -&gt; None:
    &#34;&#34;&#34;Press key play.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.play_pause"><code class="name flex">
<span>async def <span class="ident">play_pause</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Toggle between play and pause.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(5, &#34;PlayPause&#34;, &#34;Toggle between play/pause.&#34;)
async def play_pause(self) -&gt; None:
    &#34;&#34;&#34;Toggle between play and pause.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.previous"><code class="name flex">
<span>async def <span class="ident">previous</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key previous.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(9, &#34;Previous&#34;, &#34;Change to previous item.&#34;)
async def previous(self) -&gt; None:
    &#34;&#34;&#34;Press key previous.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.right"><code class="name flex">
<span>async def <span class="ident">right</span></span>(<span>self, action: <a title="pyatv.const.InputAction" href="const#pyatv.const.InputAction">InputAction</a> = InputAction.SingleTap) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key right.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(3, &#34;Right&#34;, &#34;Right button on remote.&#34;)
async def right(self, action: InputAction = InputAction.SingleTap) -&gt; None:
    &#34;&#34;&#34;Press key right.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.select"><code class="name flex">
<span>async def <span class="ident">select</span></span>(<span>self, action: <a title="pyatv.const.InputAction" href="const#pyatv.const.InputAction">InputAction</a> = InputAction.SingleTap) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key select.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(10, &#34;Select&#34;, &#34;Select current option.&#34;)
async def select(self, action: InputAction = InputAction.SingleTap) -&gt; None:
    &#34;&#34;&#34;Press key select.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.set_position"><code class="name flex">
<span>async def <span class="ident">set_position</span></span>(<span>self, pos: int) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Seek in the current playing media.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(19, &#34;SetPosition&#34;, &#34;Seek to position.&#34;)
async def set_position(self, pos: int) -&gt; None:
    &#34;&#34;&#34;Seek in the current playing media.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.set_repeat"><code class="name flex">
<span>async def <span class="ident">set_repeat</span></span>(<span>self, repeat_state: <a title="pyatv.const.RepeatState" href="const#pyatv.const.RepeatState">RepeatState</a>) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Change repeat state.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(21, &#34;SetRepeat&#34;, &#34;Change repeat state.&#34;)
async def set_repeat(self, repeat_state: const.RepeatState) -&gt; None:
    &#34;&#34;&#34;Change repeat state.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.set_shuffle"><code class="name flex">
<span>async def <span class="ident">set_shuffle</span></span>(<span>self, shuffle_state: <a title="pyatv.const.ShuffleState" href="const#pyatv.const.ShuffleState">ShuffleState</a>) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Change shuffle mode to on or off.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(20, &#34;SetShuffle&#34;, &#34;Change shuffle state.&#34;)
async def set_shuffle(self, shuffle_state: const.ShuffleState) -&gt; None:
    &#34;&#34;&#34;Change shuffle mode to on or off.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.skip_backward"><code class="name flex">
<span>async def <span class="ident">skip_backward</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Skip backwards a time interval.</p>
<p>Skip interval is typically 15-30s, but is decided by the app.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(37, &#34;SkipBackward&#34;, &#34;Skip backwards a time interval.&#34;)
async def skip_backward(self) -&gt; None:
    &#34;&#34;&#34;Skip backwards a time interval.

    Skip interval is typically 15-30s, but is decided by the app.
    &#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.skip_forward"><code class="name flex">
<span>async def <span class="ident">skip_forward</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Skip forward a time interval.</p>
<p>Skip interval is typically 15-30s, but is decided by the app.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(
    36,
    &#34;SkipForward&#34;,
    &#34;Skip forward a time interval.&#34;,
)
async def skip_forward(self) -&gt; None:
    &#34;&#34;&#34;Skip forward a time interval.

    Skip interval is typically 15-30s, but is decided by the app.
    &#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.stop"><code class="name flex">
<span>async def <span class="ident">stop</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key stop.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(7, &#34;Stop&#34;, &#34;Stop playing media.&#34;)
async def stop(self) -&gt; None:
    &#34;&#34;&#34;Press key stop.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.suspend"><code class="name flex">
<span>async def <span class="ident">suspend</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Suspend the device.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(17, &#34;Suspend&#34;, &#34;Suspend device (deprecated; use Power.turn_off).&#34;)
async def suspend(self) -&gt; None:
    &#34;&#34;&#34;Suspend the device.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.top_menu"><code class="name flex">
<span>async def <span class="ident">top_menu</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Go to main menu (long press menu).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(16, &#34;TopMenu&#34;, &#34;Go to main menu.&#34;)
async def top_menu(self) -&gt; None:
    &#34;&#34;&#34;Go to main menu (long press menu).&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.up"><code class="name flex">
<span>async def <span class="ident">up</span></span>(<span>self, action: <a title="pyatv.const.InputAction" href="const#pyatv.const.InputAction">InputAction</a> = InputAction.SingleTap) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key up.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(0, &#34;Up&#34;, &#34;Up button on remote.&#34;)
async def up(self, action: InputAction = InputAction.SingleTap) -&gt; None:
    &#34;&#34;&#34;Press key up.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.volume_down"><code class="name flex">
<span>async def <span class="ident">volume_down</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key volume down.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(13, &#34;VolumeDown&#34;, &#34;Decrease volume.&#34;)
async def volume_down(self) -&gt; None:
    &#34;&#34;&#34;Press key volume down.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.volume_up"><code class="name flex">
<span>async def <span class="ident">volume_up</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Press key volume up.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(12, &#34;VolumeUp&#34;, &#34;Increase volume.&#34;)
async def volume_up(self) -&gt; None:
    &#34;&#34;&#34;Press key volume up.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.RemoteControl.wakeup"><code class="name flex">
<span>async def <span class="ident">wakeup</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Wake up the device.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(18, &#34;WakeUp&#34;, &#34;Wake up device (deprecated; use Power.turn_on).&#34;)
async def wakeup(self) -&gt; None:
    &#34;&#34;&#34;Wake up the device.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.StateProducer"><code class="flex name class">
<span>class <span class="ident">StateProducer</span></span>
</code></dt>
<dd>
<section class="desc"><p>Base class for objects announcing state changes to a listener.</p>
<p>Initialize a new StateProducer instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StateProducer:
    &#34;&#34;&#34;Base class for objects announcing state changes to a listener.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize a new StateProducer instance.&#34;&#34;&#34;
        self.__listener: Optional[weakref.ReferenceType[Any]] = None

    @property
    def listener(self):
        &#34;&#34;&#34;Return current listener object.&#34;&#34;&#34;
        return _ListenerProxy(self.__listener)

    @listener.setter
    def listener(self, target) -&gt; None:
        &#34;&#34;&#34;Change current listener object.

        Set to None to remove active listener.
        &#34;&#34;&#34;
        if target is not None:
            self.__listener = weakref.ref(target)
        else:
            self.__listener = None</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyatv.interface.AppleTV" href="#pyatv.interface.AppleTV">AppleTV</a></li>
<li><a title="pyatv.interface.Power" href="#pyatv.interface.Power">Power</a></li>
<li><a title="pyatv.interface.PushUpdater" href="#pyatv.interface.PushUpdater">PushUpdater</a></li>
<li>pyatv.mrp.connection.MrpConnection</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyatv.interface.StateProducer.listener"><code class="name">var <span class="ident">listener</span></code></dt>
<dd>
<section class="desc"><p>Return current listener object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def listener(self):
    &#34;&#34;&#34;Return current listener object.&#34;&#34;&#34;
    return _ListenerProxy(self.__listener)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyatv.interface.Stream"><code class="flex name class">
<span>class <span class="ident">Stream</span></span>
</code></dt>
<dd>
<section class="desc"><p>Base class for stream functionality.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stream(ABC):  # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Base class for stream functionality.&#34;&#34;&#34;

    @abstractmethod
    def close(self) -&gt; None:
        &#34;&#34;&#34;Close connection and release allocated resources.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()

    @abstractmethod
    @feature(31, &#34;PlayUrl&#34;, &#34;Stream a URL on device.&#34;)
    async def play_url(self, url: str, **kwargs) -&gt; None:
        &#34;&#34;&#34;Play media from an URL on the device.&#34;&#34;&#34;
        raise exceptions.NotSupportedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyatv.airplay.AirPlayStreamAPI</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyatv.interface.Stream.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Close connection and release allocated resources.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def close(self) -&gt; None:
    &#34;&#34;&#34;Close connection and release allocated resources.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
<dt id="pyatv.interface.Stream.play_url"><code class="name flex">
<span>async def <span class="ident">play_url</span></span>(<span>self, url: str, **kwargs) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Play media from an URL on the device.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
@feature(31, &#34;PlayUrl&#34;, &#34;Stream a URL on device.&#34;)
async def play_url(self, url: str, **kwargs) -&gt; None:
    &#34;&#34;&#34;Play media from an URL on the device.&#34;&#34;&#34;
    raise exceptions.NotSupportedError()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite>.</p>
</footer>
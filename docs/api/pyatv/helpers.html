---
layout: template
title: API - pyatv.helpers
permalink: /api//helpers
link_group: api
---
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyatv" href="index">pyatv</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyatv.helpers.auto_connect" href="#pyatv.helpers.auto_connect">auto_connect</a></code></li>
</ul>
</li>
</ul>
</nav>
<article id="content">
<header>
<h1 class="title">Module <code>pyatv.helpers</code></h1>
</header>
<section id="section-intro">
<p>Various helper methods.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Various helper methods.&#34;&#34;&#34;

import asyncio
from typing import Callable, Optional

import pyatv


async def auto_connect(
    handler: Callable[[pyatv.interface.AppleTV], None],
    timeout: int = 5,
    not_found: Callable[[], None] = None,
    loop: Optional[asyncio.AbstractEventLoop] = None,
) -&gt; None:
    &#34;&#34;&#34;Connect to first discovered device.

    This is a convenience method that auto discovers devices, picks the first
    device found, connects to it and passes it to a user provided handler. An
    optional error handler can be provided that is called when no device was found.
    Very inflexible in many cases, but can be handys sometimes when trying things.

    Note: both handler and not_found must be coroutines
    &#34;&#34;&#34;
    # Scan and do connect in the event loop
    async def _handle(loop):
        atvs = await pyatv.scan(loop, timeout=timeout)

        # Take the first device found
        if atvs:
            atv = await pyatv.connect(atvs[0], loop)

            try:
                await handler(atv)
            finally:
                atv.close()
        else:
            if not_found is not None:
                await not_found()

    loop = loop or asyncio.get_event_loop()
    await _handle(loop)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyatv.helpers.auto_connect"><code class="name flex">
<span>async def <span class="ident">auto_connect</span></span>(<span>handler: Callable[[<a title="pyatv.interface.AppleTV" href="interface#pyatv.interface.AppleTV">AppleTV</a>], NoneType], timeout: int = 5, not_found: Callable[[], NoneType] = None, loop: Union[asyncio.events.AbstractEventLoop, NoneType] = None) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Connect to first discovered device.</p>
<p>This is a convenience method that auto discovers devices, picks the first
device found, connects to it and passes it to a user provided handler. An
optional error handler can be provided that is called when no device was found.
Very inflexible in many cases, but can be handys sometimes when trying things.</p>
<p>Note: both handler and not_found must be coroutines</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def auto_connect(
    handler: Callable[[pyatv.interface.AppleTV], None],
    timeout: int = 5,
    not_found: Callable[[], None] = None,
    loop: Optional[asyncio.AbstractEventLoop] = None,
) -&gt; None:
    &#34;&#34;&#34;Connect to first discovered device.

    This is a convenience method that auto discovers devices, picks the first
    device found, connects to it and passes it to a user provided handler. An
    optional error handler can be provided that is called when no device was found.
    Very inflexible in many cases, but can be handys sometimes when trying things.

    Note: both handler and not_found must be coroutines
    &#34;&#34;&#34;
    # Scan and do connect in the event loop
    async def _handle(loop):
        atvs = await pyatv.scan(loop, timeout=timeout)

        # Take the first device found
        if atvs:
            atv = await pyatv.connect(atvs[0], loop)

            try:
                await handler(atv)
            finally:
                atv.close()
        else:
            if not_found is not None:
                await not_found()

    loop = loop or asyncio.get_event_loop()
    await _handle(loop)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite>.</p>
</footer>
---
layout: template
title: API - pyatv
permalink: /api/
link_group: api
---
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyatv.conf" href="conf">pyatv.conf</a></code></li>
<li><code><a title="pyatv.const" href="const">pyatv.const</a></code></li>
<li><code><a title="pyatv.convert" href="convert">pyatv.convert</a></code></li>
<li><code><a title="pyatv.exceptions" href="exceptions">pyatv.exceptions</a></code></li>
<li><code><a title="pyatv.helpers" href="helpers">pyatv.helpers</a></code></li>
<li><code><a title="pyatv.interface" href="interface">pyatv.interface</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyatv.connect" href="#pyatv.connect">connect</a></code></li>
<li><code><a title="pyatv.pair" href="#pyatv.pair">pair</a></code></li>
<li><code><a title="pyatv.scan" href="#pyatv.scan">scan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyatv.MulticastMdnsScanner" href="#pyatv.MulticastMdnsScanner">MulticastMdnsScanner</a></code></h4>
<ul class="">
<li><code><a title="pyatv.MulticastMdnsScanner.discover" href="#pyatv.MulticastMdnsScanner.discover">discover</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<article id="content">
<header>
<h1 class="title">Module <code>pyatv</code></h1>
</header>
<section id="section-intro">
<p>Main routines for interacting with an Apple TV.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Main routines for interacting with an Apple TV.&#34;&#34;&#34;

import os
import asyncio
import logging
import datetime  # noqa
from abc import ABC, abstractmethod
from ipaddress import IPv4Address
from typing import List, Dict

import aiohttp

from pyatv import conf, exceptions, interface
from pyatv.airplay import AirPlayStreamAPI
from pyatv.const import Protocol
from pyatv.dmap import DmapAppleTV
from pyatv.dmap.pairing import DmapPairingHandler
from pyatv.mrp import MrpAppleTV
from pyatv.mrp.pairing import MrpPairingHandler
from pyatv.airplay.pairing import AirPlayPairingHandler
from pyatv.support import net, knock, udns


_LOGGER = logging.getLogger(__name__)

HOMESHARING_SERVICE: str = &#34;_appletv-v2._tcp.local&#34;
DEVICE_SERVICE: str = &#34;_touch-able._tcp.local&#34;
MEDIAREMOTE_SERVICE: str = &#34;_mediaremotetv._tcp.local&#34;
AIRPLAY_SERVICE: str = &#34;_airplay._tcp.local&#34;

ALL_SERVICES: List[str] = [
    HOMESHARING_SERVICE,
    DEVICE_SERVICE,
    MEDIAREMOTE_SERVICE,
    AIRPLAY_SERVICE,
]

# These ports have been &#34;arbitrarily&#34; chosen (see issue #580) because a device normally
# listen on them (more or less). They are used as best-effort when for unicast scanning
# to try to wake up a device. Both issue #580 and #595 are good references to read.
KNOCK_PORTS: List[int] = [3689, 7000, 49152, 32498]


class BaseScanner(ABC):  # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Base scanner for service discovery.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;Initialize a new BaseScanner.&#34;&#34;&#34;
        self._found_devices: Dict[IPv4Address, conf.AppleTV] = {}

    @abstractmethod
    async def discover(self, timeout: int):
        &#34;&#34;&#34;Start discovery of devices and services.&#34;&#34;&#34;

    def handle_response(self, response: udns.Response):
        &#34;&#34;&#34;Call when an MDNS response was received.&#34;&#34;&#34;
        for service in response.services:
            if service.address and service.port != 0:
                self._service_discovered(service)

                atv = self._found_devices.get(service.address)
                if atv:
                    atv.deep_sleep = response.deep_sleep

    def _service_discovered(self, service: udns.Service) -&gt; None:
        {
            HOMESHARING_SERVICE: self._hs_service,
            DEVICE_SERVICE: self._non_hs_service,
            MEDIAREMOTE_SERVICE: self._mrp_service,
            AIRPLAY_SERVICE: self._airplay_service,
        }.get(service.type, self._unsupported_service)(service)

    def _hs_service(self, mdns_service: udns.Service) -&gt; None:
        &#34;&#34;&#34;Add a new device to discovered list.&#34;&#34;&#34;
        name = mdns_service.properties.get(&#34;Name&#34;, &#34;Unknown&#34;)
        service = conf.DmapService(
            mdns_service.name,
            mdns_service.properties.get(&#34;hG&#34;),
            port=mdns_service.port,
            properties=mdns_service.properties,
        )
        self._handle_service(mdns_service.address, name, service)

    def _non_hs_service(self, mdns_service: udns.Service) -&gt; None:
        &#34;&#34;&#34;Add a new device without Home Sharing to discovered list.&#34;&#34;&#34;
        name = mdns_service.properties.get(&#34;CtlN&#34;, &#34;Unknown&#34;)
        service = conf.DmapService(
            mdns_service.name,
            None,
            port=mdns_service.port,
            properties=mdns_service.properties,
        )
        self._handle_service(mdns_service.address, name, service)

    def _mrp_service(self, mdns_service: udns.Service) -&gt; None:
        &#34;&#34;&#34;Add a new MediaRemoteProtocol device to discovered list.&#34;&#34;&#34;
        name = mdns_service.properties.get(&#34;Name&#34;, &#34;Unknown&#34;)
        service = conf.MrpService(
            mdns_service.properties.get(&#34;UniqueIdentifier&#34;),
            mdns_service.port,
            properties=mdns_service.properties,
        )
        self._handle_service(mdns_service.address, name, service)

    def _airplay_service(self, mdns_service: udns.Service) -&gt; None:
        &#34;&#34;&#34;Add a new AirPlay device to discovered list.&#34;&#34;&#34;
        service = conf.AirPlayService(
            mdns_service.properties.get(&#34;deviceid&#34;),
            mdns_service.port,
            properties=mdns_service.properties,
        )
        self._handle_service(mdns_service.address, mdns_service.name, service)

    def _unsupported_service(self, mdns_service: udns.Service) -&gt; None:
        &#34;&#34;&#34;Handle unsupported service.&#34;&#34;&#34;
        _LOGGER.warning(
            &#34;Discovered unknown device %s (%s)&#34;, mdns_service.name, mdns_service.type
        )

    def _handle_service(
        self, address, name: str, service: interface.BaseService
    ) -&gt; None:
        _LOGGER.debug(
            &#34;Auto-discovered %s at %s:%d (%s)&#34;,
            name,
            address,
            service.port,
            service.protocol,
        )

        atv = self._found_devices.setdefault(address, conf.AppleTV(address, name))
        atv.add_service(service)


class UnicastMdnsScanner(BaseScanner):
    &#34;&#34;&#34;Service discovery based on unicast MDNS.&#34;&#34;&#34;

    def __init__(
        self, hosts: List[IPv4Address], loop: asyncio.AbstractEventLoop
    ) -&gt; None:
        &#34;&#34;&#34;Initialize a new UnicastMdnsScanner.&#34;&#34;&#34;
        super().__init__()
        self.hosts = hosts
        self.loop = loop

    async def discover(self, timeout: int):
        &#34;&#34;&#34;Start discovery of devices and services.&#34;&#34;&#34;
        responses = await asyncio.gather(
            *[self._get_services(host, timeout) for host in self.hosts]
        )

        for response in responses:
            self.handle_response(response)
        return self._found_devices

    async def _get_services(self, host: IPv4Address, timeout: int) -&gt; udns.Response:
        port = int(os.environ.get(&#34;PYATV_UDNS_PORT&#34;, 5353))  # For testing purposes
        knocker = None
        try:
            knocker = await knock.knocker(host, KNOCK_PORTS, self.loop, timeout=timeout)
            response = await udns.unicast(
                self.loop, str(host), ALL_SERVICES, port=port, timeout=timeout
            )
        except asyncio.TimeoutError:
            return udns.Response([], False)
        finally:
            if knocker:
                knocker.cancel()
        return response


class MulticastMdnsScanner(BaseScanner):
    &#34;&#34;&#34;Service discovery based on multicast MDNS.&#34;&#34;&#34;

    def __init__(self, loop: asyncio.AbstractEventLoop):
        &#34;&#34;&#34;Initialize a new MulticastMdnsScanner.&#34;&#34;&#34;
        super().__init__()
        self.loop = loop

    async def discover(self, timeout: int):
        &#34;&#34;&#34;Start discovery of devices and services.&#34;&#34;&#34;
        responses = await udns.multicast(self.loop, ALL_SERVICES, timeout=timeout)
        for _, response in responses.items():
            self.handle_response(response)
        return self._found_devices


async def scan(
    loop: asyncio.AbstractEventLoop,
    timeout: int = 5,
    identifier: str = None,
    protocol: Protocol = None,
    hosts: List[str] = None,
) -&gt; List[conf.AppleTV]:
    &#34;&#34;&#34;Scan for Apple TVs on network and return their configurations.&#34;&#34;&#34;

    def _should_include(atv):
        if not atv.ready:
            return False

        if identifier and identifier not in atv.all_identifiers:
            return False

        if protocol and atv.get_service(protocol) is None:
            return False

        return True

    scanner: BaseScanner
    if hosts:
        scanner = UnicastMdnsScanner([IPv4Address(host) for host in hosts], loop)
    else:
        scanner = MulticastMdnsScanner(loop)

    devices = (await scanner.discover(timeout)).values()
    return [device for device in devices if _should_include(device)]


async def connect(
    config: conf.AppleTV,
    loop: asyncio.AbstractEventLoop,
    protocol: Protocol = None,
    session: aiohttp.ClientSession = None,
) -&gt; interface.AppleTV:
    &#34;&#34;&#34;Connect to a device based on a configuration.&#34;&#34;&#34;
    if config.identifier is None:
        raise exceptions.DeviceIdMissingError(&#34;no device identifier&#34;)

    service = config.main_service(protocol=protocol)

    implementation = {Protocol.DMAP: DmapAppleTV, Protocol.MRP: MrpAppleTV}.get(
        service.protocol
    )

    if not implementation:
        raise exceptions.UnsupportedProtocolError(str(service.protocol))

    # AirPlay stream API is the same for both DMAP and MRP
    airplay = AirPlayStreamAPI(config, loop)

    atv = implementation(loop, await net.create_session(session), config, airplay)
    await atv.connect()
    return atv


async def pair(
    config: conf.AppleTV,
    protocol: Protocol,
    loop: asyncio.AbstractEventLoop,
    session: aiohttp.ClientSession = None,
    **kwargs
):
    &#34;&#34;&#34;Pair a protocol for an Apple TV.&#34;&#34;&#34;
    service = config.get_service(protocol)
    if not service:
        raise exceptions.NoServiceError(
            &#34;no service available for protocol &#34; + str(protocol)
        )

    handler = {
        Protocol.DMAP: DmapPairingHandler,
        Protocol.MRP: MrpPairingHandler,
        Protocol.AirPlay: AirPlayPairingHandler,
    }.get(protocol)

    if handler is None:
        raise exceptions.UnsupportedProtocolError(str(protocol))

    return handler(config, await net.create_session(session), loop, **kwargs)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyatv.conf" href="conf">pyatv.conf</a></code></dt>
<dd>
<section class="desc"><p>Configuration used when connecting to a device …</p></section>
</dd>
<dt><code class="name"><a title="pyatv.const" href="const">pyatv.const</a></code></dt>
<dd>
<section class="desc"><p>Constants used in the public API.</p></section>
</dd>
<dt><code class="name"><a title="pyatv.convert" href="convert">pyatv.convert</a></code></dt>
<dd>
<section class="desc"><p>Various types of extraction and conversion functions.</p></section>
</dd>
<dt><code class="name"><a title="pyatv.exceptions" href="exceptions">pyatv.exceptions</a></code></dt>
<dd>
<section class="desc"><p>Local exceptions used by library.</p></section>
</dd>
<dt><code class="name"><a title="pyatv.helpers" href="helpers">pyatv.helpers</a></code></dt>
<dd>
<section class="desc"><p>Various helper methods.</p></section>
</dd>
<dt><code class="name"><a title="pyatv.interface" href="interface">pyatv.interface</a></code></dt>
<dd>
<section class="desc"><p>Public interface exposed by library …</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyatv.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>config: <a title="pyatv.conf.AppleTV" href="conf#pyatv.conf.AppleTV">AppleTV</a>, loop: asyncio.events.AbstractEventLoop, protocol: <a title="pyatv.const.Protocol" href="const#pyatv.const.Protocol">Protocol</a> = None, session: aiohttp.client.ClientSession = None) -> <a title="pyatv.interface.AppleTV" href="interface#pyatv.interface.AppleTV">AppleTV</a></span>
</code></dt>
<dd>
<section class="desc"><p>Connect to a device based on a configuration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(
    config: conf.AppleTV,
    loop: asyncio.AbstractEventLoop,
    protocol: Protocol = None,
    session: aiohttp.ClientSession = None,
) -&gt; interface.AppleTV:
    &#34;&#34;&#34;Connect to a device based on a configuration.&#34;&#34;&#34;
    if config.identifier is None:
        raise exceptions.DeviceIdMissingError(&#34;no device identifier&#34;)

    service = config.main_service(protocol=protocol)

    implementation = {Protocol.DMAP: DmapAppleTV, Protocol.MRP: MrpAppleTV}.get(
        service.protocol
    )

    if not implementation:
        raise exceptions.UnsupportedProtocolError(str(service.protocol))

    # AirPlay stream API is the same for both DMAP and MRP
    airplay = AirPlayStreamAPI(config, loop)

    atv = implementation(loop, await net.create_session(session), config, airplay)
    await atv.connect()
    return atv</code></pre>
</details>
</dd>
<dt id="pyatv.pair"><code class="name flex">
<span>async def <span class="ident">pair</span></span>(<span>config: <a title="pyatv.conf.AppleTV" href="conf#pyatv.conf.AppleTV">AppleTV</a>, protocol: <a title="pyatv.const.Protocol" href="const#pyatv.const.Protocol">Protocol</a>, loop: asyncio.events.AbstractEventLoop, session: aiohttp.client.ClientSession = None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Pair a protocol for an Apple TV.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def pair(
    config: conf.AppleTV,
    protocol: Protocol,
    loop: asyncio.AbstractEventLoop,
    session: aiohttp.ClientSession = None,
    **kwargs
):
    &#34;&#34;&#34;Pair a protocol for an Apple TV.&#34;&#34;&#34;
    service = config.get_service(protocol)
    if not service:
        raise exceptions.NoServiceError(
            &#34;no service available for protocol &#34; + str(protocol)
        )

    handler = {
        Protocol.DMAP: DmapPairingHandler,
        Protocol.MRP: MrpPairingHandler,
        Protocol.AirPlay: AirPlayPairingHandler,
    }.get(protocol)

    if handler is None:
        raise exceptions.UnsupportedProtocolError(str(protocol))

    return handler(config, await net.create_session(session), loop, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyatv.scan"><code class="name flex">
<span>async def <span class="ident">scan</span></span>(<span>loop: asyncio.events.AbstractEventLoop, timeout: int = 5, identifier: str = None, protocol: <a title="pyatv.const.Protocol" href="const#pyatv.const.Protocol">Protocol</a> = None, hosts: List[str] = None) -> List[<a title="pyatv.conf.AppleTV" href="conf#pyatv.conf.AppleTV">AppleTV</a>]</span>
</code></dt>
<dd>
<section class="desc"><p>Scan for Apple TVs on network and return their configurations.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def scan(
    loop: asyncio.AbstractEventLoop,
    timeout: int = 5,
    identifier: str = None,
    protocol: Protocol = None,
    hosts: List[str] = None,
) -&gt; List[conf.AppleTV]:
    &#34;&#34;&#34;Scan for Apple TVs on network and return their configurations.&#34;&#34;&#34;

    def _should_include(atv):
        if not atv.ready:
            return False

        if identifier and identifier not in atv.all_identifiers:
            return False

        if protocol and atv.get_service(protocol) is None:
            return False

        return True

    scanner: BaseScanner
    if hosts:
        scanner = UnicastMdnsScanner([IPv4Address(host) for host in hosts], loop)
    else:
        scanner = MulticastMdnsScanner(loop)

    devices = (await scanner.discover(timeout)).values()
    return [device for device in devices if _should_include(device)]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyatv.MulticastMdnsScanner"><code class="flex name class">
<span>class <span class="ident">MulticastMdnsScanner</span></span>
<span>(</span><span>loop: asyncio.events.AbstractEventLoop)</span>
</code></dt>
<dd>
<section class="desc"><p>Service discovery based on multicast MDNS.</p>
<p>Initialize a new MulticastMdnsScanner.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MulticastMdnsScanner(BaseScanner):
    &#34;&#34;&#34;Service discovery based on multicast MDNS.&#34;&#34;&#34;

    def __init__(self, loop: asyncio.AbstractEventLoop):
        &#34;&#34;&#34;Initialize a new MulticastMdnsScanner.&#34;&#34;&#34;
        super().__init__()
        self.loop = loop

    async def discover(self, timeout: int):
        &#34;&#34;&#34;Start discovery of devices and services.&#34;&#34;&#34;
        responses = await udns.multicast(self.loop, ALL_SERVICES, timeout=timeout)
        for _, response in responses.items():
            self.handle_response(response)
        return self._found_devices</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyatv.BaseScanner</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyatv.MulticastMdnsScanner.discover"><code class="name flex">
<span>async def <span class="ident">discover</span></span>(<span>self, timeout: int)</span>
</code></dt>
<dd>
<section class="desc"><p>Start discovery of devices and services.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def discover(self, timeout: int):
    &#34;&#34;&#34;Start discovery of devices and services.&#34;&#34;&#34;
    responses = await udns.multicast(self.loop, ALL_SERVICES, timeout=timeout)
    for _, response in responses.items():
        self.handle_response(response)
    return self._found_devices</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite>.</p>
</footer>

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Testing &#8212; pyatv 0.4.0.dev0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Troubleshooting" href="troubleshooting.html" />
    <link rel="prev" title="Developing pyatv" href="developing.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="testing">
<span id="pyatv-testing"></span><h1>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h1>
<p>To ensure good code quality and regression over time, testing is an important
part of pyatv. Mainly two types of tests are used: unit tests and functional
tests. Unit tests are used to verify small independent modules, like the DMAP
parser or conversion methods. The functional tests on the other hand, verifies
that the overall functionality works by using the public API.</p>
<p>When implementing new functionality or fixing bugs, new tests should be written.
Preferably before the actual implementation (test first). Only trivial pull
requests (like pydoc updates or style changes) will be accepted if tests are
missing.</p>
<div class="section" id="unit-testing">
<h2>Unit Testing<a class="headerlink" href="#unit-testing" title="Permalink to this headline">¶</a></h2>
<p>Regular unit tests should be implemented when adding new (internal)
functionality with a specific purpose, like a parser or converter. These
components are usually small and seldom change their external interface. When
testing a specific function, e.g. pressing “play” or fetching metadata, write
a functional test instead. This allows for greater flexibility when refactoring
since the API is not tied to the implementation too much.</p>
<p>Take look at other tests to get some inspiration, they are all in in the
<code class="docutils literal notranslate"><span class="pre">tests</span></code> directory.</p>
</div>
<div class="section" id="functional-testing">
<h2>Functional Testing<a class="headerlink" href="#functional-testing" title="Permalink to this headline">¶</a></h2>
<p>A simple overview of the functional tests setup looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="o">+-----------------+</span>                <span class="o">+-----------------------+</span>
 <span class="o">|</span>                 <span class="o">|</span> <span class="n">video_playing</span>  <span class="o">|</span>                       <span class="o">|</span>
 <span class="o">|</span>    <span class="n">Test</span> <span class="n">case</span>    <span class="o">|---------------&gt;|</span>    <span class="n">AppleTVUseCases</span>    <span class="o">|</span>
 <span class="o">|</span>                 <span class="o">|</span>                <span class="o">|</span>                       <span class="o">|</span>
 <span class="o">+--------+--------+</span>                <span class="o">+-----------------------+</span>
          <span class="o">^</span>                                     <span class="o">|</span>
          <span class="o">|</span> <span class="n">metadata</span><span class="o">.</span><span class="n">playing</span><span class="p">()</span>                  <span class="o">|</span>
          <span class="n">v</span>                                     <span class="o">|</span>
   <span class="o">+-------------+</span>                              <span class="o">|</span>
   <span class="o">|</span>             <span class="o">|</span>                              <span class="o">|</span>
   <span class="o">|</span>    <span class="n">pyatv</span>    <span class="o">|</span>                              <span class="o">|</span>
   <span class="o">|</span>             <span class="o">|</span>                              <span class="o">|</span>
   <span class="o">+-------------+</span>                              <span class="o">|</span>
          <span class="o">^</span>                                     <span class="o">|</span>
          <span class="o">|</span> <span class="n">DAAP</span><span class="o">/</span><span class="n">DMAP</span>                           <span class="o">|</span>
          <span class="n">v</span>                                     <span class="o">|</span>
<span class="o">+-------------------+</span>                           <span class="o">|</span>
<span class="o">|</span>                   <span class="o">|</span>      <span class="n">configure</span> <span class="n">video</span>      <span class="o">|</span>
<span class="o">|</span>    <span class="n">FakeAppleTV</span>    <span class="o">|&lt;--------------------------+</span>
<span class="o">|</span>                   <span class="o">|</span>
<span class="o">+-------------------+</span>
</pre></div>
</div>
<p>Explanation of each box above:</p>
<ul class="simple">
<li><p><strong>Test case</strong>: This is the actual test case. It uses (only) the public API of
pyatv and verifies that the response is correct. Implementation wise it’s an
AioHTTPTestCase (basically a regular python unittest, but async). It will
create an application based on <em>FakeAppleTV</em> (below) and a webserver for it,
that will only be accessible on localhost at a randomized port. This is what
pyatv communicates with.</p></li>
<li><p><strong>pyatv</strong>: What is being tested, which is this library. Only the public API
must be used.</p></li>
<li><p><strong>FakeAppleTV</strong>: In order to test the library, it must have an Apple TV to
communicate with. So, FakeAppleTV simulates the behavior of a real device by
listening on the correct port (on localhost) and answers to DAAP requests.
To modify what is returned by the fake device, usescases are used.</p></li>
<li><p><strong>AppleTVUseCases</strong>: Since tests want to verify different kinds of behavior,
the fake device must be set up accordingly. To make this more abstract from
the test, usescases are used and this helper realizes the usecases. Instead
of having to know what different requests should return when for instance
video is playing, just use the “video usecase”.</p></li>
</ul>
<div class="section" id="simple-example">
<h3>Simple Example<a class="headerlink" href="#simple-example" title="Permalink to this headline">¶</a></h3>
<p>To get a feeling of how a functional test looks like, have a look at this
example (boiler plate code for creating a device is done during setup):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@unittest_run_loop</span>
<span class="k">def</span> <span class="nf">test_metadata_none_type_when_not_playing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">usecase</span><span class="o">.</span><span class="n">nothing_playing</span><span class="p">()</span>

    <span class="n">playing</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">atv</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">playing</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">playing</span><span class="o">.</span><span class="n">media_type</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">MEDIA_TYPE_UNKNOWN</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">playing</span><span class="o">.</span><span class="n">play_state</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">PLAY_STATE_NO_MEDIA</span><span class="p">)</span>
</pre></div>
</div>
<p>It’s easy to see that the usecase <em>nothing_playing</em> is used, which configures
the fake device in such a way that nothing is playing. Metadata is then
fetched with the regular public API and verified to be correct. Most test
cases look like this, which make them easy to understand.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">pyatv</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="protocol.html">Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="finding_devices.html">Finding Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="pairing.html">Pairing with a device</a></li>
<li class="toctree-l1"><a class="reference internal" href="connecting.html">Connecting</a></li>
<li class="toctree-l1"><a class="reference internal" href="controlling.html">Controlling a device</a></li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">Retrieving metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="airplay.html">AirPlay Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="atvremote.html">Reference application: atvremote</a></li>
<li class="toctree-l1"><a class="reference internal" href="developing.html">Developing pyatv</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#unit-testing">Unit Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#functional-testing">Functional Testing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="developing.html" title="previous chapter">Developing pyatv</a></li>
      <li>Next: <a href="troubleshooting.html" title="next chapter">Troubleshooting</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Pierre Ståhl.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/testing.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
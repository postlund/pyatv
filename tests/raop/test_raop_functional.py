"""RAOP functional tests with fake device.

TODO: Things to improve:

* Add tests for timing server
* Improve sync tests
"""

import logging
from typing import Dict, List, Tuple

import pytest

from pyatv.const import DeviceState, FeatureName, FeatureState, MediaType
from pyatv.interface import FeatureInfo, Playing, PushListener

from tests.utils import data_path, until

pytestmark = pytest.mark.asyncio

_LOGGER = logging.getLogger(__name__)

# Number of frames per audio packet in RAOP
FRAMES_PER_PACKET = 352

METADATA_FIELDS = [FeatureName.Title, FeatureName.Artist, FeatureName.Album]
PROGRESS_FIELDS = [FeatureName.Position, FeatureName.TotalTime]


@pytest.fixture(name="playing_listener")
async def playing_listener_fixture(raop_client):
    class PlayingListener(PushListener):
        def __init__(self):
            """Initialize a new PlayingListener instance."""
            self.updates: List[Playing] = []
            self.all_features: Dict[FeatureName, FeatureInfo] = {}

        def playstatus_update(self, updater, playstatus: Playing) -> None:
            """Inform about changes to what is currently playing."""
            self.updates.append(playstatus)
            if playstatus.device_state == DeviceState.Playing:
                self.all_features = raop_client.features.all_features()

        def playstatus_error(self, updater, exception: Exception) -> None:
            """Inform about an error when updating play status."""

    listener = PlayingListener()
    raop_client.push_updater.listener = listener
    raop_client.push_updater.start()
    yield listener


def audio_matches(
    audio: bytes,
    frames: int,
    channels: int = 2,
    sample_size: int = 2,
    skip_frames: int = 0,
) -> None:
    """Assert that raw audio matches audio generated by audiogen.py."""
    succeeded = True
    frame_size = channels * sample_size

    # assert per individual frame
    for i in range(frames):
        actual = audio[i * frame_size : i * frame_size + frame_size]
        expected = frame_size * bytes([(i + skip_frames) & 0xFF])
        if actual != expected:
            _LOGGER.error("%s != %s for frame %d", actual, expected, (i + skip_frames))
            succeeded = False

    return succeeded


def assert_features_in_state(
    all_features: Dict[FeatureName, FeatureInfo],
    features: List[FeatureName],
    state: FeatureState,
) -> None:
    for feature in features:
        assert all_features[feature].state == state


@pytest.mark.parametrize(
    "raop_properties,metadata",
    [
        # Metadata supported by receiver ("md=0")
        (
            {"et": "0", "md": "0"},
            {"artist": "postlund", "album": "raop", "title": "pyatv"},
        ),
        # Metadata NOT supported by receiver
        (
            {"et": "0"},
            {"artist": None, "album": None, "title": None},
        ),
    ],
)
async def test_stream_file_verify_metadata(raop_client, raop_state, metadata):
    await raop_client.stream.stream_file(data_path("only_metadata.wav"))
    assert raop_state.metadata.artist == metadata["artist"]
    assert raop_state.metadata.album == metadata["album"]
    assert raop_state.metadata.title == metadata["title"]


@pytest.mark.parametrize("raop_properties", [({"et": "0"})])
async def test_stream_complete_file(raop_client, raop_state):
    await raop_client.stream.stream_file(data_path("audio_10_frames.wav"))

    assert audio_matches(raop_state.raw_audio, frames=10)


@pytest.mark.parametrize("raop_properties", [({"et": "4"})])
async def test_stream_complete_legacy_auth(raop_client, raop_state):
    await raop_client.stream.stream_file(data_path("audio_10_frames.wav"))

    assert raop_state.auth_setup_performed
    assert audio_matches(raop_state.raw_audio, frames=10)


@pytest.mark.parametrize(
    "raop_properties,drop_packets,enable_retransmission",
    [({"et": "0"}, 0, True), ({"et": "0"}, 2, False), ({"et": "0"}, 2, True)],
)
async def test_stream_retransmission(
    raop_client, raop_state, raop_usecase, drop_packets, enable_retransmission
):
    raop_usecase.retransmissions_enabled(enable_retransmission)
    raop_usecase.drop_n_packets(drop_packets)

    await raop_client.stream.stream_file(data_path("audio_3_packets.wav"))

    # For stability reasons: wait for all packets to be received as it might take a few
    # extra runs for the event loop to catch up
    packets_to_receive = 3 if enable_retransmission else 1
    await until(lambda: len(raop_state.audio_packets) == packets_to_receive)

    # If retransmissions are enabled, then we should always receive all packets in
    # the end (within reasons). If retransmissions are not enabled, then we should
    # start comparing the received audio stream after the amount of audio packets
    # dropped.
    start_frame = 0 if enable_retransmission else drop_packets * FRAMES_PER_PACKET
    assert audio_matches(
        raop_state.raw_audio,
        frames=3 * FRAMES_PER_PACKET - start_frame,  # Total expected frame
        skip_frames=start_frame,  # Skipping first amount of frames
    )


@pytest.mark.parametrize("raop_properties", [({"et": "0"})])
async def test_push_updates(raop_client, playing_listener):
    await raop_client.stream.stream_file(data_path("only_metadata.wav"))

    # Initial idle + audio playing + back to idle
    await until(lambda: len(playing_listener.updates) == 3)

    idle = playing_listener.updates[0]
    assert idle.device_state == DeviceState.Idle
    assert idle.media_type == MediaType.Unknown

    playing = playing_listener.updates[1]
    assert playing.device_state == DeviceState.Playing
    assert playing.media_type == MediaType.Music
    assert playing.artist == "postlund"
    assert playing.title == "pyatv"
    assert playing.album == "raop"

    idle = playing_listener.updates[2]
    assert idle.device_state == DeviceState.Idle
    assert idle.media_type == MediaType.Unknown


@pytest.mark.parametrize("raop_properties", [({"et": "0"})])
async def test_push_updates_progress(raop_client, playing_listener):
    assert_features_in_state(
        raop_client.features.all_features(),
        PROGRESS_FIELDS,
        FeatureState.Unavailable,
    )

    await raop_client.stream.stream_file(data_path("static_3sec.ogg"))

    # Initial idle + audio playing + back to idle
    await until(lambda: len(playing_listener.updates) == 3)

    playing = playing_listener.updates[1]
    assert playing.device_state == DeviceState.Playing
    assert playing.position == 0
    assert playing.total_time == 3

    assert_features_in_state(
        playing_listener.all_features,
        PROGRESS_FIELDS,
        FeatureState.Available,
    )


@pytest.mark.parametrize("raop_properties", [({"et": "0"})])
async def test_metadata_features(raop_client, playing_listener):
    # All features should be unavailable when nothing is playing
    assert_features_in_state(
        raop_client.features.all_features(),
        METADATA_FIELDS,
        FeatureState.Unavailable,
    )

    # StreamFile should be available for streaming
    assert (
        raop_client.features.get_feature(FeatureName.StreamFile).state
        == FeatureState.Available
    )
    await raop_client.stream.stream_file(data_path("only_metadata.wav"))

    # Use a listener to catch when something starts playing and save that as it's
    # too late to verify when stream_file returns (idle state will be reported).
    await until(lambda: playing_listener.all_features)

    # When playing, everything should be available
    assert_features_in_state(
        playing_listener.all_features,
        METADATA_FIELDS,
        FeatureState.Available,
    )


@pytest.mark.parametrize("raop_properties", [({"et": "0"})])
async def test_sync_packets(raop_client, raop_state):
    await raop_client.stream.stream_file(data_path("only_metadata.wav"))

    # TODO: This test doesn't really test anything, just makes sure that sync packets
    # are received. Expand this test in the future.
    await until(lambda: raop_state.sync_packets_received > 5)


@pytest.mark.parametrize(
    "raop_properties,feedback_supported", [({"et": "0"}, True), ({"et": "0"}, False)]
)
async def test_send_feedback(raop_client, raop_usecase, raop_state, feedback_supported):
    raop_usecase.feedback_enabled(feedback_supported)

    await raop_client.stream.stream_file(data_path("audio_3_packets.wav"))

    # One request is sent to see if feedback is supported, then additional requests are
    # only sent if actually supported
    if feedback_supported:
        assert raop_state.feedback_packets_received > 1
    else:
        assert raop_state.feedback_packets_received == 1
